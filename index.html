<head>
    <meta charset="UTF-8">
    <title>Nithin Varma Tic Tac Toe</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #2a2a72;
            --secondary: #009ffd;
            --accent: #ff4754;
            --background: #1a1a2e;
            --win-pulse-color-x: rgba(255, 71, 84, 0.6); /* Accent color with alpha */
            --win-pulse-color-o: rgba(46, 204, 113, 0.6); /* O color with alpha */
        }

        body {
            background: linear-gradient(135deg, var(--background) 0%, #16213e 100%);
            color: #fff;
            font-family: 'Poppins', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        
        .title {
            font-size: 2.8em;
            margin: 10px 0;
            background: linear-gradient(45deg, var(--secondary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .rules {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1em;
            margin: 15px 0;
            max-width: 500px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 25px 0;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative; /* Needed for potential future animations */
        }

        .cell.popping {
            animation: cellPop 0.3s ease-out;
        }

        .cell.winning-cell {
            animation: winPulse 1.2s infinite ease-in-out;
        }
        .cell.winning-cell.x { --win-pulse-color: var(--win-pulse-color-x); }
        .cell.winning-cell.o { --win-pulse-color: var(--win-pulse-color-o); }

        .cell.x { color: var(--accent); }
        .cell.o { color: #2ecc71; }

        /* Ultimate Tic Tac Toe Styling */
        .ultimate-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 25px 0;
            background: rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .small-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            background: rgba(255, 255, 255, 0.08);
            padding: 10px;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .small-board.active {
            box-shadow: 0 0 15px rgba(255, 71, 84, 0.8);
            transform: scale(1.03);
        }

        .small-board.won-x {
            background: rgba(255, 71, 84, 0.3);
        }

        .small-board.won-o {
            background: rgba(46, 204, 113, 0.3);
        }

        .small-cell {
            width: 35px;
            height: 35px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative; /* Needed for potential future animations */
        }

        .small-cell.popping {
            animation: cellPop 0.3s ease-out;
        }

        /* Winning pulse for small cells (used if we highlight individual cells in ultimate) */
        .small-cell.winning-cell {
            animation: winPulse 1.2s infinite ease-in-out;
        }
        .small-cell.winning-cell.x { --win-pulse-color: var(--win-pulse-color-x); }
        .small-cell.winning-cell.o { --win-pulse-color: var(--win-pulse-color-o); }

        .small-cell.x { color: var(--accent); }
        .small-cell.o { color: #2ecc71; }

        .board-win-marker {
            position: absolute;
            font-size: 5em;
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        #status {
            margin: 15px 0;
            font-size: 1.4em;
            font-weight: 500;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 25px;
            border-radius: 8px;
        }

        #roast {
            color: var(--accent);
            font-style: italic;
            margin: 10px 0;
            min-height: 24px;
            text-align: center;
            opacity: 0.9;
            transition: opacity 0.3s ease, transform 0.3s ease;
            transform: translateY(10px); /* Start slightly lower */
            opacity: 0; /* Start hidden */
        }

        #roast.roast-visible {
            opacity: 0.9;
            transform: translateY(0); /* Slide up to original position */
            animation: roastAppear 0.3s ease-out;
        }

        button {
            padding: 12px 30px;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            border: none;
            color: white;
            cursor: pointer;
            margin: 15px 0;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); /* Added default shadow */
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 159, 253, 0.4);
        }

        button:active {
            transform: translateY(1px) scale(0.98); /* Click feedback */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* Slightly reduced shadow */
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
            opacity: 1;
        }

        .mode-description {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .mode-description.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .board.shuffle {
            transition: transform 0.5s ease;
        }

        .cell-content {
            transition: opacity 0.3s ease;
        }

        .cell-content.fade-out {
            opacity: 0;
        }

        .small-board.ultimate-win {
            border: 3px solid gold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            animation: winPulse 1.2s infinite ease-in-out;
            --win-pulse-color: rgba(255, 215, 0, 0.7); /* Gold color for pulse */
        }

        @keyframes cellPop {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1); }
        }

        @keyframes winPulse {
            0% { background-color: rgba(255, 255, 255, 0.08); box-shadow: 0 0 0px var(--win-pulse-color); }
            50% { background-color: var(--win-pulse-color); box-shadow: 0 0 15px var(--win-pulse-color); }
            100% { background-color: rgba(255, 255, 255, 0.08); box-shadow: 0 0 0px var(--win-pulse-color); }
        }

        @keyframes roastAppear {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 0.9;
                transform: translateY(0);
            }
        }

        .difficulty-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            border-radius: 20px;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }

        .difficulty-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .difficulty-btn.active {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            border-color: var(--secondary);
            box-shadow: 0 0 10px rgba(0, 159, 253, 0.4);
        }

    </style>
</head>
<body>
    <h1 class="title">Nithin Varma Tic Tac Toe</h1>
    
    <div class="mode-toggle">
        <button onclick="toggleMode('classic')" id="classicMode">Classic Mode</button>
        <button onclick="toggleMode('memory')" id="memoryMode">Memory Mode</button>
        <button onclick="toggleMode('shuffle')" id="shuffleMode">Shuffled Mode</button>
        <button onclick="toggleMode('ultimate')" id="ultimateMode">Ultimate Mode</button>
        <button onclick="toggleMode('bolt')" id="boltMode">Bolt Mode</button>
        <button onclick="toggleMode('computer')" id="computerMode">Play vs Computer</button>
        <button onclick="startTournamentSetup()" id="tournamentModeBtn">Tournament Mode</button>
        <button onclick="showAboutScreen()" id="aboutGameBtn">About Game</button>
    </div>

    <!-- Tournament Setup Screen -->
    <div id="tournamentSetup" style="display: none; background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 8px; margin: 15px 0; width: 90%; max-width: 400px; text-align: center;">
        <h2>Tournament Setup</h2>
        <div>
            <label for="player1Name">Player 1 (X) Name:</label>
            <input type="text" id="player1Name" value="Player 1" style="padding: 5px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc;">
        </div>
        <div>
            <label for="player2Type">Player 2:</label>
            <select id="player2Type" onchange="toggleTournamentComputerOptions()" style="padding: 5px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc;">
                <option value="human">Human</option>
                <option value="computer">Computer</option>
            </select>
        </div>
        <div id="tournamentComputerOptions" style="display: none; margin-bottom: 10px;">
            <label for="tournamentAIDifficulty">AI Difficulty:</label>
            <select id="tournamentAIDifficulty" style="padding: 5px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc;">
                <option value="easy">Easy</option>
                <option value="hard" selected>Hard</option>
                <option value="brutal">Brutal</option>
            </select>
        </div>
        <div>
            <label for="player2Name">Player 2 (O) Name:</label>
            <input type="text" id="player2Name" value="Player 2" style="padding: 5px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc;">
        </div>
        <!-- Optional: Add round selection here later if needed -->
        <button onclick="initializeTournament()">Start Tournament</button>
        <button onclick="exitTournamentSetup()">Cancel</button>
    </div>

    <!-- Computer Game Setup Screen -->
    <div id="computerSetupScreen" style="display: none; background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 8px; margin: 15px 0; width: 90%; max-width: 450px; text-align: center;">
        <h2>Play vs Computer Setup</h2>
        
        <!-- Mode Selection -->
        <div style="margin-bottom: 15px;">
            <h4>Select Game Mode:</h4>
            <select id="computerGameMode" style="padding: 8px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc; width: 80%;">
                <option value="classic">Classic</option>
                <option value="memory">Memory</option>
                <option value="shuffle">Shuffled</option>
                <option value="ultimate">Ultimate</option>
                <option value="bolt">Bolt</option> // Added Bolt option
            </select>
        </div>

        <!-- Difficulty Selection -->
        <div style="margin-bottom: 20px;">
            <h4>Select Difficulty:</h4>
            <div style="display: flex; justify-content: center; gap: 10px;">
                <button onclick="setAIDifficulty('easy')" class="difficulty-btn" data-difficulty="easy">Easy</button>
                <button onclick="setAIDifficulty('hard')" class="difficulty-btn active" data-difficulty="hard">Hard</button> 
                <button onclick="setAIDifficulty('brutal')" class="difficulty-btn" data-difficulty="brutal">Brutal</button>
            </div>
            <input type="hidden" id="aiDifficulty" value="hard"> <!-- Default to hard -->
        </div>

        <button onclick="startComputerGame()">Start Game</button>
        <button onclick="cancelComputerSetup()">Cancel</button>
    </div>

    <!-- Tournament Progress Display -->
    <div id="tournamentProgress" style="display: none; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0; width: 90%; max-width: 500px; text-align: center;">
        <h3 id="tournamentRoundTitle">Round X: Mode</h3>
        <div style="display: flex; justify-content: space-around; margin-top: 10px; font-size: 1.1em;">
            <span id="tournamentPlayer1Info">Player 1: 0</span>
            <span id="tournamentPlayer2Info">Player 2: 0</span>
        </div>
    </div>

    <div id="classicRules" class="rules mode-description active">
        <h3>Classic Game Rules:</h3>
        <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
            <li>Players take turns placing their mark (X or O) in an empty square.</li>
            <li>The first player to get three of their marks in a row (up, down, across, or diagonally) is the winner.</li>
            <li>When all 9 squares are full, the game is over. If no player has 3 marks in a row, the game ends in a draw.</li>
        </ul>
    </div>

    <div id="memoryRules" class="rules mode-description">
        <h3>Memory Mode Rules:</h3>
        <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
            <li>Each player takes turns placing their mark (X or O) on the grid.</li>
            <li>Your mark disappears after clicking! Remember your moves!</li>
            <li>If you click on an already filled box, you lose your turn & get roasted.</li>
            <li>First player to get three marks in a row, column, or diagonal wins.</li>
            <li>Once the game ends, all marks will be revealed.</li>
        </ul>
    </div>
    
    <div id="shuffleRules" class="rules mode-description">
        <h3>Shuffled Mode Rules:</h3>
        <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
            <li>Everything from the <strong>Memory Mode</strong> applies, BUT...</li>
            <li>After each turn, the grid slightly shifts position!</li>
            <li>Your memory will be tested as you track moving cells.</li>
            <li>Wrong moves still cost you your turn.</li>
            <li>Are you up for this mind-bending challenge?</li>
        </ul>
    </div>
    
    <div id="ultimateRules" class="rules mode-description">
        <h3>Ultimate Tic Tac Toe Rules:</h3>
        <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
            <li>The main board consists of 9 smaller Tic Tac Toe boards in a 3Ã—3 grid.</li>
            <li>First move can be anywhere on any small board.</li>
            <li>The position of your move determines which small board your opponent must play in next.</li>
            <li>Win a small board by getting three in a row within it.</li>
            <li>Win the game by winning three small boards in a row.</li>
            <li>If sent to a full or already won board, you can play in any available board.</li>
        </ul>
    </div>

    <!-- New Rules Section for Bolt Mode -->
    <div id="boltRules" class="rules mode-description">
        <h3>Bolt Mode Rules:</h3>
        <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
            <li>Standard Tic-Tac-Toe rules apply (get 3 in a row).</li>
            <li>Each player can only have a maximum of 3 marks on the board at any given time.</li>
            <li>When you place your 4th mark, your oldest mark disappears.</li>
            <li>Plan your moves carefully as the board keeps changing!</li>
        </ul>
    </div>

    <div class="board" id="board">
        <div class="cell" data-index="0"></div>
        <div class="cell" data-index="1"></div>
        <div class="cell" data-index="2"></div>
        <div class="cell" data-index="3"></div>
        <div class="cell" data-index="4"></div>
        <div class="cell" data-index="5"></div>
        <div class="cell" data-index="6"></div>
        <div class="cell" data-index="7"></div>
        <div class="cell" data-index="8"></div>
    </div>
    
    <div class="ultimate-board" id="ultimateBoard" style="display: none;">
        <!-- 9 small boards, each with 9 cells will be generated by JavaScript -->
    </div>

    <div id="status">Current Player: <span style="color: var(--accent)">X</span></div>
    <div id="roast"></div>
    <button onclick="resetGame()">New Game</button>
    <button id="backToModesBtn" onclick="goBackToModes()" style="display: none; margin-left: 10px;">Back to Modes</button> 
    <button id="nextRoundBtn" onclick="nextTournamentRound()" style="display: none; margin-left: 10px;">Next Round</button>

    <!-- Tournament Results Screen -->
    <div id="tournamentResults" style="display: none; background: rgba(42, 42, 114, 0.9); padding: 30px; border-radius: 15px; margin: 20px 0; width: 90%; max-width: 500px; text-align: center; border: 2px solid var(--secondary); box-shadow: 0 0 20px rgba(0, 159, 253, 0.5);">
        <h2 id="tournamentWinner" style="color: gold; font-size: 2em; margin-bottom: 15px;">Champion: Player X</h2>
        <h3>Final Score</h3>
        <p id="tournamentFinalScoreP1" style="font-size: 1.2em;">Player 1: X points</p>
        <p id="tournamentFinalScoreP2" style="font-size: 1.2em;">Player 2: Y points</p>
        <!-- Add round summary here later if needed -->
        <div style="margin-top: 25px;">
            <button onclick="rematchTournament()">Rematch</button>
            <button onclick="exitTournament()">Back to Modes</button>
        </div>
    </div>

    <!-- About Game Screen -->
    <div id="aboutGameScreen" style="display: none; background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 8px; margin: 15px 0; width: 90%; max-width: 600px; text-align: left; line-height: 1.6;">
        <h2>About the Game</h2>
        <p>Strategic Tic Tac Toe is a fresh take on the classic game, adding memory challenges and spatial twists that make every round more unpredictable and exciting. With multiple modes and a tournament feature, it's designed for both casual fun and serious face-offs.</p>

        <h3>Game Modes:</h3>
        <ul>
            <li><strong>Classic Mode</strong><br>
The original Tic Tac Toe experience with visible moves and standard rules. A familiar favorite for quick and casual games.</li>
            <li><strong>Memory Mode</strong> â€“ <em>Concept by Nithin Varma</em><br>
A twist where the board is hidden after each turn. Players must remember their moves â€” one mistake can flip the outcome.</li>
            <li><strong>Shuffled Grid Mode</strong> â€“ <em>Concept by Nithin Varma</em><br>
The grid slightly shifts positions after each move, testing your memory and spatial tracking.</li>
            <li><strong>Ultimate Tic Tac Toe</strong> â€“ <em>Discovered online</em><br>
A popular variant where each cell in a 3Ã—3 grid is its own Tic Tac Toe board. While there's no single creator, a widely played version was developed by Michael Xing.</li>
            <li><strong>Bolt Mode</strong> â€“ <em>A New Strategic Challenge!</em><br>
                <p>Bolt Mode is a fast-paced variant of Tic-Tac-Toe where marks disappear based on placement order, creating a dynamic and strategic gameplay experience.</p>
                <strong>How It Works:</strong>
                <ul>
                    <li><strong>Standard Tic-Tac-Toe Rules:</strong> Players aim to get three in a row just like traditional Tic-Tac-Toe.</li>
                    <li><strong>Limited Marks:</strong> Each player can have a maximum of three marks (X's or O's) on the board at a time.</li>
                    <li><strong>Disappearing Marks:</strong> When a player places their fourth mark, the oldest mark automatically disappears, ensuring only three marks remain on the grid at all times.</li>
                    <li><strong>Strategic Advantage:</strong> Players must carefully plan their moves, as marks disappear over time. This allows new winning opportunities to emerge while also disrupting the opponent's strategy.</li>
                </ul>
            </li>
        </ul>

        <h3>Developed By:</h3>
        <p><strong>Nithin Varma</strong></p>
        
        <button onclick="hideAboutScreen()" style="margin-top: 15px;">Back to Modes</button>
    </div>

    <script>
        let currentPlayer = 'X';
        let gameBoard = Array(9).fill('');
        let gameActive = true;
        let isPlayingAgainstAI = false; // Flag for AI mode
        let currentMode = 'classic';
        let aiDifficulty = 'hard'; // Add variable for AI difficulty
        let playerXMoves = []; // Track X's moves in order for Bolt mode
        let playerOMoves = []; // Track O's moves in order for Bolt mode
        let isProcessingClick = false; // Flag to prevent rapid click issues
        
        // Tournament State
        let isTournamentMode = false;
        let isTournamentVsComputer = false; // NEW: Track if tournament is vs computer
        let tournamentAIDifficulty = 'hard'; // NEW: Track AI difficulty for tournament
        let tournamentPlayers = [{ name: 'Player 1', score: 0 }, { name: 'Player 2', score: 0 }];
        let currentTournamentRound = 0; // 0 means not started, 1-based index for rounds
        const tournamentRounds = [
            { mode: 'classic', points: 1, name: 'Classic' },
            { mode: 'memory', points: 1, name: 'Memory' },
            { mode: 'shuffle', points: 1, name: 'Shuffled' },
            { mode: 'bolt', points: 2, name: 'Bolt' }, // Added Bolt Mode
            { mode: 'ultimate', points: 2, name: 'Ultimate' }
        ];
        let totalTournamentRounds = tournamentRounds.length;
        
        // DOM Elements (cache some for performance)
        const statusDisplay = document.getElementById('status');
        const roastDisplay = document.getElementById('roast');
        const classicBoard = document.getElementById('board');
        const ultimateBoardElement = document.getElementById('ultimateBoard');
        const tournamentSetupScreen = document.getElementById('tournamentSetup');
        const tournamentProgressDisplay = document.getElementById('tournamentProgress');
        const tournamentResultsScreen = document.getElementById('tournamentResults');
        const computerSetupScreen = document.getElementById('computerSetupScreen'); // Cache Computer Setup Screen
        const nextRoundButton = document.getElementById('nextRoundBtn');
        const newGameButton = document.querySelector('button[onclick="resetGame()"]');
        const modeToggleButtons = document.querySelector('.mode-toggle');
        const rulesDescriptions = document.querySelectorAll('.rules.mode-description');
        const tournamentModeButton = document.getElementById('tournamentModeBtn'); // Cache button
        const aboutGameButton = document.getElementById('aboutGameBtn');       // Cache button
        const aboutGameScreen = document.getElementById('aboutGameScreen');     // Cache screen
        const backToModesButton = document.getElementById('backToModesBtn');   // Cache Back button
        
        // For Ultimate Tic Tac Toe
        let ultimateBoard = Array(9).fill().map(() => Array(9).fill(''));
        let smallBoardWinners = Array(9).fill('');
        let nextBoardIndex = -1; // -1 means any board is valid for the next move
        
        // Store timeout IDs per cell for memory/shuffle modes
        let cellFadeTimeouts = {};
        let cellClearTimeouts = {};
        
        // Store timeout IDs for animations
        let fadeOutTimeoutId = null;
        let clearCellTimeoutId = null;

        const roasts = [
            // Light & Playful + Slightly Savage
            "That spot's taken, genius!",
            "You really thought that was empty?",
            "Nice try, but pay attention!",
            "Clicking randomly won't help!",
            "Oops! Lost your turn!",
            "Your memory needs a software update ðŸ§ ðŸ’¾",
            "Did you think this was a Sudoku puzzle or what?",
            "Even Google Maps couldn't help you find that spot.", // Adapted slightly
            "You had one job. ONE. ðŸ˜¤",
            "That was less Tic Tac Toe, more Tick Tick Oops.", // Adapted slightly
            "Bro blinked and forgot the whole board.",
            "I've seen better clicks from a goldfish.", // Adapted slightly
            "Are you trying to help your opponent?"
        ];

        function showRoast(message) {
            const roastElement = document.getElementById('roast');
            roastElement.textContent = message;
            roastElement.classList.add('roast-visible'); // Trigger animation
            // Use a longer timeout to ensure text stays visible during fade-out if needed
            setTimeout(() => {
                roastElement.classList.remove('roast-visible');
                 // Optional: Clear text after fade-out animation completes
                 // setTimeout(() => roastElement.textContent = '', 300); // Match CSS transition duration
            }, 2000); // How long the roast stays visible before starting to fade
        }

        function checkWin() {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            return winPatterns.find(pattern => 
                pattern.every(index => gameBoard[index] === currentPlayer)
            );
        }

        function checkSmallBoardWin(boardIndex) {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            
            return winPatterns.find(pattern => 
                pattern.every(cellIndex => ultimateBoard[boardIndex][cellIndex] === currentPlayer)
            );
        }

        function checkUltimateWin() {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            
            return winPatterns.find(pattern => 
                pattern.every(index => smallBoardWinners[index] === currentPlayer)
            );
        }

        function checkDraw() {
            return gameBoard.every(cell => cell !== '');
        }

        function checkUltimateDraw() {
            // Check if all small boards are either won or full
            return smallBoardWinners.every((winner, index) => {
                if (winner !== '') return true; // Board already won
                return ultimateBoard[index].every(cell => cell !== ''); // Board is full
            });
        }

        function isSmallBoardFull(boardIndex) {
            return ultimateBoard[boardIndex].every(cell => cell !== '');
        }

        function toggleMode(mode) {
            console.log(`toggleMode entered. Requested mode: ${mode}. Current mode: ${currentMode}`); // Log entry
            // Allow re-clicking computer mode to bring up setup if it was somehow hidden
            if (currentMode === mode && mode !== 'computer') { 
                console.log("toggleMode: Same mode requested, returning.");
                return;
            }

            const previousMode = currentMode; // Store previous mode
            currentMode = mode; // Update global mode immediately
            console.log(`toggleMode: Set currentMode to ${currentMode}`);

            // Update UI button styles - Ensure computer button is highlighted correctly
            document.querySelectorAll('.mode-toggle button').forEach(btn => {
                let isActive = (btn.id === (currentMode + 'Mode')) || (currentMode === 'computer' && btn.id === 'computerMode');
                 // Handle special case button IDs if they don't follow the pattern
                 if (!document.getElementById(currentMode + 'Mode') && currentMode === 'computer') {
                      isActive = (btn.id === 'computerMode');
                  } // Add similar checks for tournament/about if needed

                 btn.style.background = isActive 
                     ? 'linear-gradient(45deg, var(--primary), var(--secondary))' 
                     : 'rgba(255, 255, 255, 0.1)';
             });


            // Handle specific 'computer' mode selection -> Show Setup Screen
            if (currentMode === 'computer') { // Check the updated currentMode
                console.log("toggleMode: Condition (currentMode === 'computer') is TRUE. Previous mode was:", previousMode);
                console.log("toggleMode: Calling showComputerSetupScreen()...");
                showComputerSetupScreen();
                console.log("toggleMode: Returned from showComputerSetupScreen(). Executing return; to prevent further setup.");
                return; // Stop further processing in toggleMode for computer
            }

            // --- This part should ONLY run if currentMode is NOT 'computer' --- 
            console.log("toggleMode: Condition (currentMode === 'computer') is FALSE. Proceeding to setup for mode:", currentMode);
             // Switching to a non-computer mode (e.g., classic, memory, etc.)
            isPlayingAgainstAI = false; // Ensure AI is off

            resetGame();
            
            // Update UI
            document.getElementById('classicMode').style.background = mode === 'classic' 
                ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                : 'rgba(255, 255, 255, 0.1)';
                
            document.getElementById('memoryMode').style.background = mode === 'memory'
                ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                : 'rgba(255, 255, 255, 0.1)';
                
            document.getElementById('shuffleMode').style.background = mode === 'shuffle'
                ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                : 'rgba(255, 255, 255, 0.1)';
                
            document.getElementById('ultimateMode').style.background = mode === 'ultimate'
                ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                : 'rgba(255, 255, 255, 0.1)';
            
            document.getElementById('boltMode').style.background = mode === 'bolt' // Style for Bolt Mode
                ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                : 'rgba(255, 255, 255, 0.1)';
            
            // Reset AI mode button style unless it's the selected mode
            document.getElementById('computerMode').style.background = mode === 'computer'
                ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                : 'rgba(255, 255, 255, 0.1)';
            
            // Toggle rules visibility
            // Hide all rules first
            rulesDescriptions.forEach(el => el.classList.remove('active'));
            // Show the correct rule description
            const rulesId = mode + 'Rules';
            const rulesElement = document.getElementById(rulesId);
            if (rulesElement) { 
                 rulesElement.classList.add('active'); 
            } else if (mode === 'computer') { 
                // If computer mode is selected directly (or via setup), show classic rules
                document.getElementById('classicRules').classList.add('active');
            }
            
            // Toggle board visibility
            document.getElementById('board').style.display = (mode === 'ultimate') ? 'none' : 'grid'; // Classic board for most modes
            document.getElementById('ultimateBoard').style.display = mode === 'ultimate' ? 'grid' : 'none';
            
            // Add appropriate classes to board
            const board = document.getElementById('board');
            board.classList.toggle('shuffle', mode === 'shuffle');
            
            // Set AI flag - This will be set by startComputerGame now
            // isPlayingAgainstAI = (mode === 'computer'); 
            
            // Handle specific 'computer' mode selection -> Show Setup Screen
            if (mode === 'computer') {
                // Don't immediately start the game. Show the setup screen.
                showComputerSetupScreen();
                return; // Stop further processing in toggleMode for computer
            } else {
                 // Switching to a non-computer mode (e.g., classic, memory, etc.)
                 console.log(`Mode is ${mode}, switching from computer setup or another mode.`);
                 isPlayingAgainstAI = false; // Ensure AI is off
                 cancelComputerSetup(); // Just hide the setup screen if it was visible

                 // Ensure mode buttons are visible (might have been hidden by setup)
                 modeToggleButtons.style.display = 'flex';

                 // Show the correct board for the selected non-computer mode
                 if (currentMode === 'ultimate') {
                     classicBoard.style.display = 'none';
                     ultimateBoardElement.style.display = 'grid';
                 } else {
                     ultimateBoardElement.style.display = 'none';
                     classicBoard.style.display = 'grid';
                 }

                 // Show appropriate rules
                 rulesDescriptions.forEach(el => el.classList.remove('active'));
                 const rulesId = currentMode + 'Rules';
                 const rulesElement = document.getElementById(rulesId);
                 if (rulesElement) { rulesElement.classList.add('active'); }

                 // Reset game state and show controls
                 resetGame(); // Reset board state for the new mode. resetGame calls updateStatus.
                 showGameControls(); // Show New Game/Back buttons
                 statusDisplay.style.display = 'block'; // Ensure status is visible
                 roastDisplay.style.display = 'block';  // Ensure roast is visible
            }
            
            // If NOT in tournament mode, ensure standard UI elements are visible
            if (!isTournamentMode) {
                statusDisplay.style.display = 'block';
                roastDisplay.style.display = 'block';
                newGameButton.style.display = 'inline-block'; 
                nextRoundButton.style.display = 'none'; // Ensure hidden outside tournament
            }
            
            // For Ultimate mode, make sure the board is initialized
            if (mode === 'ultimate') {
                initializeUltimateBoard();
            }
            
            document.getElementById('board').style.transform = 'none';
            document.getElementById('roast').classList.remove('roast-visible'); // Hide roast
            
            // Update status display
            updateStatus(); // Moved updateStatus call here to reflect changes immediately
        }

        function initializeUltimateBoard() {
            const ultimateBoardElement = document.getElementById('ultimateBoard');
            ultimateBoardElement.innerHTML = '';
            
            // Create 9 small boards
            for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                const smallBoard = document.createElement('div');
                smallBoard.className = 'small-board';
                smallBoard.dataset.boardIndex = boardIndex;
                smallBoard.style.position = 'relative';
                
                // Create 9 cells for each small board
                for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                    const cell = document.createElement('div');
                    cell.className = 'small-cell';
                    cell.dataset.boardIndex = boardIndex;
                    cell.dataset.cellIndex = cellIndex;
                    
                    cell.addEventListener('click', () => handleUltimateClick(boardIndex, cellIndex));
                    
                    smallBoard.appendChild(cell);
                }
                
                ultimateBoardElement.appendChild(smallBoard);
            }
            
            updateUltimateUI();
        }
        
        function updateUltimateUI() {
            // Update all cells based on ultimateBoard array
            document.querySelectorAll('.small-cell').forEach(cell => {
                const boardIndex = parseInt(cell.dataset.boardIndex);
                const cellIndex = parseInt(cell.dataset.cellIndex);
                const value = ultimateBoard[boardIndex][cellIndex];
                
                cell.textContent = value;
                cell.className = 'small-cell';
                if (value === 'X') cell.classList.add('x');
                if (value === 'O') cell.classList.add('o');
            });
            
            // Update small board states
            document.querySelectorAll('.small-board').forEach(board => {
                const boardIndex = parseInt(board.dataset.boardIndex);
                
                // Clear previous classes and remove existing markers first
                const existingMarker = board.querySelector('.board-win-marker');
                if (existingMarker) {
                    existingMarker.remove();
                }
                board.className = 'small-board'; // Reset classes
                
                // Add active class if this is the next board to play in
                if (gameActive && (nextBoardIndex === boardIndex || (nextBoardIndex === -1 && smallBoardWinners[boardIndex] === '' && !isSmallBoardFull(boardIndex)))) {
                    board.classList.add('active');
                }
                
                // Add won class if this board has been won
                if (smallBoardWinners[boardIndex] === 'X') {
                    board.classList.add('won-x');
                    
                    // If there's no win marker yet, add one
                    if (!board.querySelector('.board-win-marker')) {
                        const marker = document.createElement('div');
                        marker.className = 'board-win-marker';
                        marker.textContent = 'X';
                        board.appendChild(marker);
                    }
                } else if (smallBoardWinners[boardIndex] === 'O') {
                    board.classList.add('won-o');
                    
                    // If there's no win marker yet, add one
                    if (!board.querySelector('.board-win-marker')) {
                        const marker = document.createElement('div');
                        marker.className = 'board-win-marker';
                        marker.textContent = 'O';
                        board.appendChild(marker);
                    }
                }
            });
            
            document.querySelectorAll('.small-board').forEach(board => {
                board.classList.remove('ultimate-win'); // Remove ultimate win highlight
            });
            
            document.getElementById('board').style.transform = 'none';
            document.getElementById('roast').classList.remove('roast-visible'); // Hide roast
        }
        
        function handleUltimateClick(boardIndex, cellIndex) {
            console.log(`handleUltimateClick called: board=${boardIndex}, cell=${cellIndex}. Current player: ${currentPlayer}. AI Mode: ${isPlayingAgainstAI}`); // Log entry
            if (!gameActive) return;
            
            // Check if this is a valid move
            // Either nextBoardIndex is -1 (any board) or matches the current boardIndex
            // And the board must not be already won
            // And the cell must be empty
            if ((nextBoardIndex === -1 || nextBoardIndex === boardIndex) && 
                smallBoardWinners[boardIndex] === '' && 
                ultimateBoard[boardIndex][cellIndex] === '') {
                
                // Make the move
                ultimateBoard[boardIndex][cellIndex] = currentPlayer;
                const cellElement = document.querySelector(`.small-cell[data-board-index="${boardIndex}"][data-cell-index="${cellIndex}"]`);
                cellElement.classList.add('popping'); // Add pop animation
                cellElement.addEventListener('animationend', () => cellElement.classList.remove('popping'), { once: true }); // Remove class after animation
                
                let justWonSmallBoard = false;
                // Check if this move wins the small board
                if (smallBoardWinners[boardIndex] === '' && checkSmallBoardWin(boardIndex)) {
                    smallBoardWinners[boardIndex] = currentPlayer;
                    justWonSmallBoard = true; // Mark that this move won the small board
                    
                    // Check if this wins the entire game
                    const winningPattern = checkUltimateWin();
                    if (winningPattern) {
                        gameActive = false;
                        updateUltimateUI(); // Update UI to show the last small board win marker
                        visualizeUltimateWin(winningPattern); // Highlight the winning boards
                        // Tournament Mode Check
                        if (isTournamentMode) {
                            handleTournamentGameEnd(currentPlayer);
                        } else {
                            document.getElementById('status').textContent = `Player ${currentPlayer} wins the game!`;
                        }
                        return; // Game Over
                    }
                }
                
                // Check for a draw (only if the game isn't already won)
                if (checkUltimateDraw()) {
                    gameActive = false;
                    // Tournament Mode Check
                    if (isTournamentMode) {
                        handleTournamentGameEnd('Draw');
                    } else {
                        document.getElementById('status').textContent = "It's a Draw!";
                    }
                     updateUltimateUI(); // Update UI one last time for draw
                    return;
                }
                
                // Set the next board based on the cell played
                nextBoardIndex = cellIndex;
                
                // If the next board is already won or full, player can choose any board
                if (smallBoardWinners[nextBoardIndex] !== '' || isSmallBoardFull(nextBoardIndex)) {
                    nextBoardIndex = -1;
                }
                
                // Switch players
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                updateStatus();
                console.log(`handleUltimateClick: Player switched to ${currentPlayer}. Next board target: ${nextBoardIndex}`); // Log player switch
                
                // Update the UI
                updateUltimateUI();
                // Trigger AI move if applicable AFTER UI update and player switch
                // If in tournament vs computer, only trigger AI if it's O's turn
                if (isTournamentVsComputer && currentPlayer === 'O' && gameActive) {
                    triggerAIMove();
                } else if (!isTournamentVsComputer) {
                    triggerAIMove();
                }

            } else if (ultimateBoard[boardIndex][cellIndex] !== '') {
                showRoast(roasts[Math.floor(Math.random() * roasts.length)]);
            } else if (smallBoardWinners[boardIndex] !== '' || isSmallBoardFull(boardIndex)) {
                // If the click was invalid because the small board was already won/full
                // but the click was otherwise in a valid *location* if nextBoardIndex was -1
                showRoast("This small board is already complete!");
            } else {
                showRoast("You must play in the highlighted board!");
            }
        }

        function shuffleBoard() {
            if (currentMode !== 'shuffle') return;
            const board = document.getElementById('board');
            const randomX = (Math.random() - 0.5) * 20;
            const randomY = (Math.random() - 0.5) * 20;
            const randomRotate = (Math.random() - 0.5) * 5;
            board.style.transform = `translate(${randomX}px, ${randomY}px) rotate(${randomRotate}deg)`;
        }

        function handleClick(index) {
            // Prevent processing if already handling a click
            if (isProcessingClick) {
                console.log("Rapid click detected, ignoring.");
                return;
            }

            // Lock the function
            isProcessingClick = true;
            // Add log to show state at start of handle click
            console.log(`handleClick Start: Index ${index}, Player ${currentPlayer}. Bolt Moves X: ${JSON.stringify(playerXMoves)}, O: ${JSON.stringify(playerOMoves)}`);

            try {
                if (!gameActive || gameBoard[index] !== '') { // Check if game active AND cell is empty
                    // Handle invalid move (roast, switch turn for memory/shuffle, etc.)
                    if (gameBoard[index] !== '' && (currentMode === 'memory' || currentMode === 'shuffle')) {
                        showRoast(roasts[Math.floor(Math.random() * roasts.length)]);
                        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                        updateStatus();
                        if (currentMode === 'shuffle') shuffleBoard();
                        console.log("handleClick (Memory/Shuffle - invalid move): Player lost turn, triggering AI move.");
                        // No 'return' here needed as the finally block will execute.
                        // Trigger AI move *after* releasing the lock in finally.
                    } else if (gameBoard[index] !== '' && currentMode === 'bolt') {
                        // Log the specific invalid move case for Bolt
                        console.log(`handleClick Bolt: Invalid move on occupied cell ${index}. Cell contains: ${gameBoard[index]}. Showing roast.`);
                        showRoast("Oops! That spot is taken.");
                    } else if (!gameActive) {
                         console.log(`handleClick: Invalid move on cell ${index}. Game not active.`);
                    } else {
                        // Catch-all for other invalid clicks (e.g., classic mode on occupied cell)
                        console.log(`handleClick: Invalid move on occupied cell ${index} in ${currentMode} mode. Cell contains: ${gameBoard[index]}.`);
                    }

                    // Crucial return check for occupied cells in non-memory/shuffle modes
                    if (!gameActive) {
                        console.log("handleClick: Game not active, returning.");
                        return;
                    }
                    if (gameBoard[index] !== '' && (currentMode !== 'memory' && currentMode !== 'shuffle')) {
                        // Log before returning due to occupied cell in Bolt/Classic/AI
                        console.log(`handleClick: Cell ${index} occupied in ${currentMode} mode. Returning before placing mark.`);
                        return;
                    }
                    // If we reach here, it must be a memory/shuffle invalid click where the player was switched, so we proceed to the finally block to potentially trigger AI.
                    console.log(`handleClick: Invalid move logic complete for memory/shuffle on cell ${index}. Proceeding to finally.`);

                } else { // --- Valid Move --- Only execute if cell was empty and game active
                    const cell = document.querySelector(`[data-index="${index}"]`);

                    // Bolt Mode: Check for oldest mark removal BEFORE placing the new one
                    if (currentMode === 'bolt') {
                        let playerMoves = (currentPlayer === 'X') ? playerXMoves : playerOMoves;
                        console.log(`Bolt Mode Check: Player ${currentPlayer}, Moves: ${JSON.stringify(playerMoves)}, Length: ${playerMoves.length}`); // Log state before check

                        if (playerMoves.length === 3) { // Check if player *already* has 3 marks
                            console.log(`Bolt Mode Action: Player ${currentPlayer} has 3 marks. Removing oldest.`); // Log action
                            const oldestMoveIndex = playerMoves.shift(); // Get and remove oldest index from tracking array
                            console.log(`Bolt Mode Action: Oldest index to remove: ${oldestMoveIndex}`); // Log index
                            gameBoard[oldestMoveIndex] = ''; // Remove from game board state
                            const oldestCell = document.querySelector(`[data-index="${oldestMoveIndex}"]`);
                            if (oldestCell) {
                                console.log(`Bolt Mode Action: Clearing cell ${oldestMoveIndex} visually.`); // Log visual clear
                                oldestCell.textContent = ''; // Clear visual mark
                                oldestCell.classList.remove('x', 'o');
                            } else {
                                console.error(`Bolt Mode Error: Could not find cell with index ${oldestMoveIndex} to remove mark.`);
                            }
                        } else {
                            console.log(`Bolt Mode Check: Player ${currentPlayer} has < 3 marks (${playerMoves.length}). No removal needed.`); // Log no removal
                        }
                    }

                    // Place the new mark logically and visually
                    console.log(`Bolt Mode: Placing mark ${currentPlayer} at index ${index}.`); // Log placement
                    gameBoard[index] = currentPlayer;
                    if (currentMode === 'memory' || currentMode === 'shuffle') {
                        const cellContent = document.createElement('div');
                        cellContent.className = 'cell-content';
                        cellContent.textContent = currentPlayer;
                        cell.innerHTML = ''; // Clear previous content
                        cell.appendChild(cellContent);
                        cell.classList.add(currentPlayer.toLowerCase());
                        cellFadeTimeouts[index] = setTimeout(() => {
                            cellContent.classList.add('fade-out');
                            cellClearTimeouts[index] = setTimeout(() => {
                                const currentCellContent = cell.querySelector('.cell-content');
                                if (currentCellContent) { cell.innerHTML = ''; }
                            }, 300);
                        }, 400);
                    } else {
                        cell.textContent = currentPlayer;
                        cell.classList.add(currentPlayer.toLowerCase());
                    }

                    // Add popping animation
                    cell.classList.add('popping');
                    cell.addEventListener('animationend', () => cell.classList.remove('popping'), { once: true });

                    // Bolt Mode: Add the new move index AFTER placing the mark and removing the old one (if applicable)
                    if (currentMode === 'bolt') {
                        let playerMoves = (currentPlayer === 'X') ? playerXMoves : playerOMoves;
                        playerMoves.push(index); // Add the new move index to the tracking array
                        console.log(`Bolt Mode Update: Added index ${index} for ${currentPlayer}. New Moves: ${JSON.stringify(playerMoves)}, New Length: ${playerMoves.length}`);
                    }

                    // --- Check for Win/Draw ---
                    const winningPattern = checkWin();
                    if (winningPattern) {
                        gameActive = false;
                        clearAllCellTimeouts();
                        if (currentMode === 'shuffle' || currentMode === 'bolt') {
                            document.getElementById('board').style.transform = 'none';
                        }
                        revealBoard(winningPattern);
                        if (isTournamentMode) {
                            handleTournamentGameEnd(currentPlayer);
                        } else {
                            document.getElementById('status').textContent = `Player ${currentPlayer} wins!`;
                        }
                        return; // Exit after win
                    }

                    if (checkDraw()) {
                        gameActive = false;
                        clearAllCellTimeouts();
                        if (currentMode === 'shuffle' || currentMode === 'bolt') {
                            document.getElementById('board').style.transform = 'none';
                        }
                        revealBoard();
                        if (isTournamentMode) {
                            handleTournamentGameEnd('Draw');
                        } else {
                            document.getElementById('status').textContent = "It's a Draw!";
                        }
                        return; // Exit after draw
                    }

                    // --- Switch Player and Trigger AI/Shuffle ---
                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                    updateStatus();

                    if (currentMode === 'shuffle') shuffleBoard();
                } // End of valid move block

            } finally {
                // Unlock the function
                isProcessingClick = false;
                console.log(`handleClick End: Releasing lock. Player is now ${currentPlayer}.`);

                // Trigger AI move *after* the lock is released and player has been potentially switched
                // This check needs to be outside the 'valid move' block to handle AI trigger after invalid memory/shuffle moves too.
                console.log(`handleClick Finally: Checking for AI trigger. isAI=${isPlayingAgainstAI}, current=${currentPlayer}, active=${gameActive}`);
                // If in tournament vs computer, only trigger AI if it's O's turn
                if (isTournamentVsComputer && currentPlayer === 'O' && gameActive) {
                    triggerAIMove();
                } else if (!isTournamentVsComputer) {
                    triggerAIMove();
                }
            }
        }

        function revealBoard(winningPattern = null) {
            document.querySelectorAll('.cell').forEach((cell, index) => {
                // Ensure the cell content is visible and correct class is applied
                cell.innerHTML = ''; // Clear any potential animated divs
                cell.textContent = gameBoard[index];
                cell.classList.remove('x', 'o', 'winning-cell'); // Remove old classes first, including win highlight
                if (gameBoard[index] === 'X') {
                    cell.classList.add('x');
                } else if (gameBoard[index] === 'O') {
                    cell.classList.add('o');
                }
                
                // Add winning cell highlight if applicable
                if (winningPattern && winningPattern.includes(index)) {
                    cell.classList.add('winning-cell');
                }
            });

            // If playing against AI, trigger AI's turn after human moves
            triggerAIMove();
        }

        function updateStatus() {
            let statusText = "";
            const playerColor = currentPlayer === 'X' ? 'var(--accent)' : '#2ecc71';

            if (isTournamentMode) {
                const currentPlayerName = currentPlayer === 'X' ? tournamentPlayers[0].name : tournamentPlayers[1].name;
                statusText = `Current Player: ${currentPlayerName} (<span style="color: ${playerColor}">${currentPlayer}</span>)`;
            } else if (isPlayingAgainstAI) {
                const difficultyDisplay = aiDifficulty.charAt(0).toUpperCase() + aiDifficulty.slice(1);
                const modeDisplay = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
                if (currentPlayer === 'X') {
                    statusText = `Your Turn (<span style="color: ${playerColor}">X</span>) vs Computer (${modeDisplay} [${difficultyDisplay}])`;
                } else {
                    statusText = `Computer's Turn (<span style="color: ${playerColor}">O</span>) (${modeDisplay} [${difficultyDisplay}])`;
                }
            } else {
                statusText = `Current Player: <span style="color: ${playerColor}">${currentPlayer}</span>`;
            }
            
            // Append Ultimate mode specific info if applicable
            if (currentMode === 'ultimate' && gameActive) {
                if (nextBoardIndex === -1) {
                    statusText += ' - Play in any available board';
                } else {
                    statusText += ` - Play in board ${nextBoardIndex + 1}`;
                }
            }
            
            statusDisplay.innerHTML = statusText;
        }

        function resetGame() {
            console.log(`Executing resetGame... isPlayingAgainstAI: ${isPlayingAgainstAI}, isTournamentMode: ${isTournamentMode}`); // Log entry with state
            gameBoard.fill('');
            gameActive = true;
            currentPlayer = 'X';
            
            // Reset Ultimate Tic Tac Toe state
            ultimateBoard = Array(9).fill().map(() => Array(9).fill(''));
            smallBoardWinners = Array(9).fill('');
            nextBoardIndex = -1;

            // Clear all pending cell timeouts on reset
            clearAllCellTimeouts();
            console.log("resetGame finished."); // Log exit
 
            // Reset Bolt mode move tracking
            playerXMoves = [];
            playerOMoves = [];
            // Add log to confirm reset
            console.log(`resetGame: Cleared Bolt moves. X: ${JSON.stringify(playerXMoves)}, O: ${JSON.stringify(playerOMoves)}`);
            
            // Reset UI
            document.querySelectorAll('.cell').forEach(cell => {
                cell.textContent = '';
                cell.className = 'cell'; // Remove any added classes
            });
            
            // Update Ultimate board if that's the current mode
            if (currentMode === 'ultimate') {
                // Ensure ultimate board is reset and displayed correctly
                initializeUltimateBoard(); 
            }
            
            // Update status, but only if not in tournament mode OR if called explicitly
            // During tournament round start, status is updated separately
            if (!isTournamentMode) { 
                 updateStatus();
            } else if (isPlayingAgainstAI) {
                // If starting an AI game (maybe from a tournament mode later?)
                updateStatus();
            } else {
                // In tournament mode, resetGame is called by toggleMode when starting a round.
                // We need to ensure the status display reflects the current tournament player.
                updateStatus(); 
            }

            // Update status and buttons based on game state (AI, tournament, or normal)
            updateStatus(); // Always update status first

            // Reset button text/action based on whether AI mode is active
            if (isPlayingAgainstAI) {
                newGameButton.textContent = 'Change AI Settings';
                newGameButton.onclick = showComputerSetupScreen; // Go back to setup
                backToModesButton.style.display = 'inline-block'; 
                console.log("resetGame (AI branch): Set back button display to inline-block");
            } else if (isTournamentMode) {
                 // In tournament, button text/action is set elsewhere (initializeTournament, startTournamentRound)
                 newGameButton.textContent = 'Abandon Tournament'; // Make sure this is set if reset is called mid-tournament
                 newGameButton.onclick = confirmAbandonTournament;
                 backToModesButton.style.display = 'none'; // Explicitly hide in tournament
                 console.log("resetGame (Tournament branch): Hid back button");
            } else {
                // Standard non-AI, non-tournament game
                newGameButton.textContent = 'New Game';
                newGameButton.onclick = resetGame; // Standard reset
                backToModesButton.style.display = 'inline-block';
                console.log("resetGame (Standard branch): Set back button display to inline-block");
            }

            // Clear all pending cell timeouts on reset
            clearAllCellTimeouts();
        }

        function visualizeUltimateWin(winningPattern) {
            winningPattern.forEach(boardIndex => {
                const boardElement = document.querySelector(`.small-board[data-board-index="${boardIndex}"]`);
                // Remove previous state classes before adding the ultimate win class
                boardElement.classList.remove('won-x', 'won-o', 'active'); 
                if (boardElement) {
                     boardElement.classList.add('ultimate-win');
                 }
            });
        }

        function clearAllCellTimeouts() {
            Object.values(cellFadeTimeouts).forEach(clearTimeout);
            Object.values(cellClearTimeouts).forEach(clearTimeout);
            cellFadeTimeouts = {};
            cellClearTimeouts = {};
        }

        function triggerAIMove() {
            console.log(`triggerAIMove called. Conditions: isAI=${isPlayingAgainstAI}, player=${currentPlayer}, active=${gameActive}, mode=${currentMode}`);
            if (isPlayingAgainstAI && currentPlayer === 'O' && gameActive) {
                
                // Select correct board based on mode
                const targetBoard = currentMode === 'ultimate' ? ultimateBoardElement : classicBoard;
                targetBoard.style.pointerEvents = 'none'; // Disable player clicks

                console.log(`AI Turn triggered (Mode: ${currentMode}, Difficulty: ${aiDifficulty}). Setting timeout.`);
                
                setTimeout(() => {
                    console.log('AI Timeout: Calculating move...');
                    let aiMove = null;
                    
                    if (currentMode === 'ultimate') {
                        console.log(`AI Timeout: Current player ${currentPlayer}, nextBoardIndex: ${nextBoardIndex}`); // Log state before move calc
                        aiMove = makeUltimateAIMove(aiDifficulty);
                         console.log(`AI Timeout: makeUltimateAIMove returned: ${JSON.stringify(aiMove)}`); // Log the returned object
                         if (aiMove && typeof aiMove.boardIndex !== 'undefined' && typeof aiMove.cellIndex !== 'undefined') {
                            console.log(`AI Timeout: Valid move object received. Calling handleUltimateClick(${aiMove.boardIndex}, ${aiMove.cellIndex})`);
                            handleUltimateClick(aiMove.boardIndex, aiMove.cellIndex); // AI makes its ultimate move
                    } else {
                            console.log('AI Timeout: Ultimate AI move index is null, cannot play.');
                         }
                    } else {
                        // Classic, Memory, Shuffle modes
                        aiMove = makeAIMove(aiDifficulty);
                        console.log(`AI Timeout: makeAIMove returned: ${aiMove}`);
                        if (aiMove !== null) {
                            console.log(`AI Timeout: Calling handleClick(${aiMove})`);
                            handleClick(aiMove); // AI makes its classic/memory/shuffle move
                        } else {
                            console.log('AI Timeout: Classic AI move index is null, cannot play.');
                        }
                    }
                    
                    targetBoard.style.pointerEvents = 'auto'; // Re-enable player clicks
                }, 600); // 600ms delay
            } else {
                console.log('AI Turn conditions not met or not AI turn.');
            }
        }

        function makeAIMove(difficulty) {
            console.log(`Calculating AI move for 3x3 board. Difficulty: ${difficulty}`);
            const aiPlayer = 'O';
            const humanPlayer = 'X';
            let board = [...gameBoard]; // Use the internal game board state
            const availableMoves = board.map((val, idx) => val === '' ? idx : null).filter(val => val !== null);

            if (availableMoves.length === 0) return null; // No moves possible

            // Difficulty: Easy -> ~50% chance of random move, otherwise proceed to Hard logic
            if (difficulty === 'easy' && Math.random() < 0.5) {
                 console.log("AI Easy: Making random move");
                 return availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }
            
            // Difficulty: Brutal (Placeholder - for now, same as Hard)
            // TODO: Implement Minimax for Brutal difficulty
            if (difficulty === 'brutal') {
                console.log("AI Brutal: Using Hard logic (Minimax TODO)");
                // Fallthrough to Hard logic for now
            }
            
            // --- Hard Logic (and fallback for Easy/Brutal) ---
            console.log("AI Hard: Evaluating strategic moves...");

            // Helper to check if a move is winning for a player
            const isWinningMove = (player, index) => {
                if (board[index] !== '') return false;
                board[index] = player; // Temporarily make the move
                const win = checkWinInternal(board, player); // Check win with temp board
                board[index] = ''; // Undo the move
                return win;
            };

            // Helper to check for wins based on a specific board state
            const checkWinInternal = (currentBoard, player) => {
                const winPatterns = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6]
                ];
                return winPatterns.some(pattern => 
                    pattern.every(idx => currentBoard[idx] === player)
                );
            };

            // 1. Check if AI can win in the next move
            for (let i = 0; i < 9; i++) {
                if (isWinningMove(aiPlayer, i)) {
                    return i;
                }
            }

            // 2. Check if human can win in the next move, and block them
            for (let i = 0; i < 9; i++) {
                if (isWinningMove(humanPlayer, i)) {
                    return i;
                }
            }

            // 3. Try to take the center if it's free
            if (board[4] === '') {
                return 4;
            }

            // 4. Try to take opposite corner (if player took a corner)
            const corners = [0, 2, 6, 8];
            const oppositeCorners = { 0: 8, 2: 6, 6: 2, 8: 0 };
            for (const corner of corners) {
                if (board[corner] === humanPlayer && board[oppositeCorners[corner]] === '') {
                    return oppositeCorners[corner];
                }
            }

            // 5. Try to take any empty corner
            const emptyCorners = corners.filter(i => board[i] === '');
            if (emptyCorners.length > 0) {
                return emptyCorners[Math.floor(Math.random() * emptyCorners.length)]; // Pick random empty corner
            }

            // 6. Try to take any empty side
            const sides = [1, 3, 5, 7];
            const emptySides = sides.filter(i => board[i] === '');
            if (emptySides.length > 0) {
                return emptySides[Math.floor(Math.random() * emptySides.length)]; // Pick random empty side
            }

            // Should not happen in Tic Tac Toe if logic is correct, but fallback
             return availableMoves.length > 0 ? availableMoves[Math.floor(Math.random() * availableMoves.length)] : null;
        }

        function makeUltimateAIMove(difficulty) {
            console.log(`Calculating AI move for Ultimate board. Difficulty: ${difficulty}, Next Board: ${nextBoardIndex}`);
            const aiPlayer = 'O';
            const humanPlayer = 'X';

            let possibleMoves = [];

            // Determine valid boards to play in
            let validBoardIndices = [];
            if (nextBoardIndex === -1) {
                // Can play in any board that isn't won or full
                for (let i = 0; i < 9; i++) {
                    if (smallBoardWinners[i] === '' && !isSmallBoardFull(i)) {
                        validBoardIndices.push(i);
                    }
                }
            } else if (smallBoardWinners[nextBoardIndex] === '' && !isSmallBoardFull(nextBoardIndex)) {
                // Must play in the specified board
                validBoardIndices.push(nextBoardIndex);
            } else {
                // Sent to a finished board, can play anywhere else that's valid
                 for (let i = 0; i < 9; i++) {
                    if (smallBoardWinners[i] === '' && !isSmallBoardFull(i)) {
                        validBoardIndices.push(i);
                    }
                }
            }
            
            if (validBoardIndices.length === 0) {
                 console.log("Ultimate AI: No valid boards to play in! Returning null.");
                 return null; // No moves possible
            }
            console.log("Ultimate AI: Valid boards to play in:", validBoardIndices);

            // Find all available cells within the valid boards
            validBoardIndices.forEach(boardIdx => {
                for (let cellIdx = 0; cellIdx < 9; cellIdx++) {
                    if (ultimateBoard[boardIdx][cellIdx] === '') {
                        possibleMoves.push({ boardIndex: boardIdx, cellIndex: cellIdx });
                    }
                }
            });

            if (possibleMoves.length === 0) {
                 console.log("Ultimate AI: No empty cells in valid boards! Returning null.");
                 return null; // Should not happen if validBoardIndices has boards
            }
            console.log(`Ultimate AI: Found ${possibleMoves.length} possible moves:`, JSON.stringify(possibleMoves));

            // --- Difficulty Logic --- 
             // TODO: Implement Hard/Brutal strategies for Ultimate

             // Easy: Choose a random valid move
            if (difficulty === 'easy') {
                console.log(`Ultimate AI Easy: Choosing random move from ${possibleMoves.length} options.`);
                const chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                console.log("Ultimate AI Easy: Chosen move:", JSON.stringify(chosenMove));
                return chosenMove;
            }
            
            // Hard / Brutal (Placeholder: Use Easy logic for now)
            if (difficulty === 'hard' || difficulty === 'brutal') {
                console.log(`Ultimate AI ${difficulty}: Using Easy logic (Strategy TODO).`);
                const chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                console.log(`Ultimate AI ${difficulty}: Chosen move:`, JSON.stringify(chosenMove));
                return chosenMove;
            }
            
            // Fallback (shouldn't be reached)
            return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
        }

        // Set up the game
        document.querySelectorAll('.cell').forEach(cell => 
            cell.addEventListener('click', () => handleClick(parseInt(cell.dataset.index)))
        );
        
        // === Tournament Mode Functions ===

        function startTournamentSetup() {
            exitTournament(); // Ensure any previous state is cleared
            hideAllScreens();
            tournamentSetupScreen.style.display = 'block';
            modeToggleButtons.style.display = 'none'; // Hide mode buttons
            // Style the active button
            tournamentModeButton.style.background = 'linear-gradient(45deg, var(--primary), var(--secondary))';
            aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)'; // Reset other special button
        }

        function exitTournamentSetup() {
            tournamentSetupScreen.style.display = 'none';
            modeToggleButtons.style.display = 'flex'; // Show mode buttons
            // Reset special button styles
            tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)';
            aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)';
            toggleMode('classic'); // Default back to classic view
        }

        function initializeTournament() {
            const player1Name = document.getElementById('player1Name').value || 'Player 1';
            const player2Type = document.getElementById('player2Type').value;
            const player2Name = player2Type === 'computer' ? 'Computer' : (document.getElementById('player2Name').value || 'Player 2');
            isTournamentVsComputer = player2Type === 'computer';
            if (isTournamentVsComputer) {
                tournamentAIDifficulty = document.getElementById('tournamentAIDifficulty').value;
            }
            isTournamentMode = true;
            tournamentPlayers = [
                { name: player1Name, score: 0 },
                { name: player2Name, score: 0 }
            ];
            currentTournamentRound = 0; // Will be incremented by nextTournamentRound to 1
            hideAllScreens();
            tournamentSetupScreen.style.display = 'none';
            tournamentProgressDisplay.style.display = 'block';
            modeToggleButtons.style.display = 'none'; // Keep mode buttons hidden
            newGameButton.textContent = 'Abandon Tournament'; // Change button text
            newGameButton.onclick = confirmAbandonTournament;
            // Ensure the main status/roast displays are hidden initially in tournament
            statusDisplay.style.display = 'none'; 
            roastDisplay.style.display = 'none';
            nextTournamentRound(); // Start the first round
        }
        
        function hideAllScreens() {
            // Hide game boards, rules, setup, results, etc.
            classicBoard.style.display = 'none';
            ultimateBoardElement.style.display = 'none';
            rulesDescriptions.forEach(el => el.classList.remove('active'));
            tournamentSetupScreen.style.display = 'none';
            tournamentProgressDisplay.style.display = 'none';
            tournamentResultsScreen.style.display = 'none';
            nextRoundButton.style.display = 'none';
            statusDisplay.style.display = 'none'; // Hide regular status during setup/results
            roastDisplay.style.display = 'none';
        }
        
        function confirmAbandonTournament() {
            if (confirm('Are you sure you want to abandon the current tournament?')) {
                exitTournament();
            }
        }

        function exitTournament() {
            isTournamentMode = false;
            currentTournamentRound = 0;
            tournamentPlayers = [{ name: 'Player 1', score: 0 }, { name: 'Player 2', score: 0 }];
            
            hideAllScreens();
            modeToggleButtons.style.display = 'flex'; // Show mode buttons again
            newGameButton.textContent = 'New Game'; // Reset button text
            newGameButton.onclick = resetGame; // Reset button action
            statusDisplay.style.display = 'block'; // Show status
            roastDisplay.style.display = 'block'; // Show roast area
            
            // Reset special button styles
            tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)';
            aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)';
            
            // Ensure the correct default mode view is shown
            const defaultMode = 'classic';
            document.getElementById(defaultMode + 'Rules').classList.add('active');
            classicBoard.style.display = 'grid'; // Show classic board by default
            ultimateBoardElement.style.display = 'none';
            toggleMode(defaultMode); // Set internal state and button styles
        }

        function nextTournamentRound() {
            currentTournamentRound++;
            if (currentTournamentRound <= totalTournamentRounds) {
                startTournamentRound();
            } else {
                showTournamentResults();
            }
        }
        
        function startTournamentRound() {
            const roundInfo = tournamentRounds[currentTournamentRound - 1];
            // Update progress display
            document.getElementById('tournamentRoundTitle').textContent = 
                `Round ${currentTournamentRound}: ${roundInfo.name} (${roundInfo.points} ${roundInfo.points === 1 ? 'point' : 'points'})`;
            document.getElementById('tournamentPlayer1Info').textContent = 
                `${tournamentPlayers[0].name} (X): ${tournamentPlayers[0].score}`;
            document.getElementById('tournamentPlayer2Info').textContent = 
                `${tournamentPlayers[1].name} (O): ${tournamentPlayers[1].score}`;
            tournamentProgressDisplay.style.display = 'block'; // Ensure progress is visible
            nextRoundButton.style.display = 'none'; // Hide button until round ends
            statusDisplay.style.display = 'block'; // Show status for the game round
            roastDisplay.style.display = 'block'; // Show roast area
            // Set the game mode for the current round
            // This will also call resetGame internally to prepare the board
            toggleMode(roundInfo.mode); 
            // Ensure the correct board is visible after toggleMode (handles early return case)
            if (roundInfo.mode === 'ultimate') {
                classicBoard.style.display = 'none';
                ultimateBoardElement.style.display = 'grid';
                initializeUltimateBoard(); // Ensure it's freshly drawn
            } else {
                classicBoard.style.display = 'grid';
                ultimateBoardElement.style.display = 'none';
            }
            // If tournament vs computer, set AI flag and difficulty for this round
            if (isTournamentVsComputer) {
                isPlayingAgainstAI = true;
                aiDifficulty = tournamentAIDifficulty;
            } else {
                isPlayingAgainstAI = false;
            }
            // If computer is O and starts, trigger AI move
            if (isTournamentVsComputer && currentPlayer === 'O') {
                setTimeout(triggerAIMove, 600);
            }
        }
        
        function handleTournamentGameEnd(winner) {
            // Placeholder - will implement scoring and next steps here
            console.log(`Tournament Round ${currentTournamentRound} ended. Winner: ${winner}`);
            
            const roundInfo = tournamentRounds[currentTournamentRound - 1];
            let pointsAwarded = roundInfo.points;
            let winnerName = "";
            if (winner === 'X') {
                tournamentPlayers[0].score += pointsAwarded;
                winnerName = tournamentPlayers[0].name;
            } else if (winner === 'O') {
                tournamentPlayers[1].score += pointsAwarded;
                winnerName = tournamentPlayers[1].name;
            }

            // Update score display immediately
            document.getElementById('tournamentPlayer1Info').textContent = 
                `${tournamentPlayers[0].name} (X): ${tournamentPlayers[0].score}`;
            document.getElementById('tournamentPlayer2Info').textContent = 
                `${tournamentPlayers[1].name} (O): ${tournamentPlayers[1].score}`;

            // Show result message in the status area
            if (winner === 'Draw') {
                statusDisplay.textContent = `Round ${currentTournamentRound} ends in a Draw!`;
            } else {
                statusDisplay.textContent = `${winnerName} wins Round ${currentTournamentRound} (+${pointsAwarded} points)!`;
            }
            
            gameActive = false; // Ensure game stops
            nextRoundButton.style.display = 'none'; // Hide button for seamless auto-progression

            // Automatically transition to the next round after a short delay
            setTimeout(() => {
                if (currentTournamentRound < totalTournamentRounds) {
                    nextTournamentRound();
                } else {
                    showTournamentResults();
                }
            }, 1800); // 1.8 seconds for user to see result
        }
        
        function showTournamentResults() {
            // Placeholder - will implement the final results screen
            console.log("Tournament finished. Showing results.");
            hideAllScreens(); // Hide game elements
            tournamentProgressDisplay.style.display = 'block'; // Keep progress visible for context

            const p1Score = tournamentPlayers[0].score;
            const p2Score = tournamentPlayers[1].score;
            let winnerMessage = "";

            if (p1Score > p2Score) {
                winnerMessage = `ðŸ† Champion: ${tournamentPlayers[0].name} ðŸ†`;
            } else if (p2Score > p1Score) {
                winnerMessage = `ðŸ† Champion: ${tournamentPlayers[1].name} ðŸ†`;
            } else {
                winnerMessage = "ðŸ† It's a Tie! ðŸ†";
            }

            document.getElementById('tournamentWinner').textContent = winnerMessage;
            document.getElementById('tournamentFinalScoreP1').textContent = `${tournamentPlayers[0].name}: ${p1Score} points`;
            document.getElementById('tournamentFinalScoreP2').textContent = `${tournamentPlayers[1].name}: ${p2Score} points`;

            tournamentResultsScreen.style.display = 'block';
        }
        
        function rematchTournament() {
            // Simply re-initialize with the same players
            currentTournamentRound = 0;
            tournamentPlayers[0].score = 0;
            tournamentPlayers[1].score = 0;
            
            hideAllScreens();
            tournamentResultsScreen.style.display = 'none';
            tournamentProgressDisplay.style.display = 'block';
            newGameButton.textContent = 'Abandon Tournament'; // Ensure button is correct
            newGameButton.onclick = confirmAbandonTournament;
            
            nextTournamentRound(); // Start round 1 again
        }

        // === About Screen Functions ===
        function showAboutScreen() {
            exitTournament(); // Use exitTournament to reset to a clean state first
            hideAllScreens(); 
            aboutGameScreen.style.display = 'block';
            modeToggleButtons.style.display = 'none'; // Hide mode buttons
            // Style the active button
            aboutGameButton.style.background = 'linear-gradient(45deg, var(--primary), var(--secondary))';
            tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)'; // Reset other special button
        }

        function hideAboutScreen() {
            aboutGameScreen.style.display = 'none';
             // Reset special button styles (will be handled by exitTournament call below)
            exitTournament(); // Use exitTournament to restore the default main menu view
        }
        // ==============================

        // === Computer AI Functions ===

        function showComputerSetupScreen() {
            console.log("Executing showComputerSetupScreen..."); // Log entry
            // exitTournament(); // DO NOT CALL THIS HERE - It resets the view!
            hideAllScreens(); // Hide other content first
            computerSetupScreen.style.display = 'block';
            modeToggleButtons.style.display = 'none'; // Hide mode buttons
            newGameButton.style.display = 'none'; // Hide new game button during setup
            backToModesButton.style.display = 'none'; // Hide back button during setup
            // Style the active button
            document.getElementById('computerMode').style.background = 'linear-gradient(45deg, var(--primary), var(--secondary))';
            // Reset other special buttons
            tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)'; 
            aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)';
            // Reset difficulty selection UI to default (hard)
            setAIDifficulty('hard'); 
             // Reset mode dropdown to classic
            document.getElementById('computerGameMode').value = 'classic';
            console.log("showComputerSetupScreen finished."); // Log exit
        }

        function cancelComputerSetup() {
            console.log("Executing cancelComputerSetup...");
            computerSetupScreen.style.display = 'none';
            // Don't force view changes here, let toggleMode handle it.
            // Reset the computerMode button style if it was active
            document.getElementById('computerMode').style.background = 'rgba(255, 255, 255, 0.1)';
            // We also need to ensure the main action buttons become visible again
            // if the user cancels setup *without* choosing another mode (e.g. clicking cancel button)
            // Check if we are NOT currently in a game (AI or tournament)
            if (!isPlayingAgainstAI && !isTournamentMode) {
                 modeToggleButtons.style.display = 'flex'; // Show mode buttons
                 newGameButton.style.display = 'inline-block'; // Show new game button
                 backToModesButton.style.display = 'none'; // Hide back button
                 // Reset new game button
                 newGameButton.textContent = 'New Game';
                 newGameButton.onclick = resetGame;
                 // Ensure default rules/view?
                 document.getElementById('classicRules').classList.add('active'); 
             }
        }

        function setAIDifficulty(difficulty) {
            aiDifficulty = difficulty;
            document.getElementById('aiDifficulty').value = difficulty; // Update hidden input (though we use the variable directly)
            // Update button styles
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.difficulty === difficulty) {
                    btn.classList.add('active');
                }
            });
        }

        function startComputerGame() {
            const selectedMode = document.getElementById('computerGameMode').value;
            // Difficulty is already set in aiDifficulty via setAIDifficulty
            
            isPlayingAgainstAI = true;
            currentMode = selectedMode;
            console.log(`startComputerGame: Set isPlayingAgainstAI=${isPlayingAgainstAI}, currentMode=${currentMode}`); // Log state
            
            hideAllScreens();
            computerSetupScreen.style.display = 'none';
            modeToggleButtons.style.display = 'none'; // Keep mode buttons hidden
            newGameButton.style.display = 'inline-block'; // Show button, text/action updated in resetGame
            statusDisplay.style.display = 'block';
            roastDisplay.style.display = 'block';

            // Toggle rules visibility based on selected mode
            rulesDescriptions.forEach(el => el.classList.remove('active'));
            const rulesId = currentMode + 'Rules';
            const rulesElement = document.getElementById(rulesId);
            if (rulesElement) { 
                rulesElement.classList.add('active'); 
            } else { // Should not happen if modes match rules divs
                document.getElementById('classicRules').classList.add('active');
            }
            
            // Show the correct board
            if (currentMode === 'ultimate') {
                classicBoard.style.display = 'none';
                ultimateBoardElement.style.display = 'grid';
            } else {
                classicBoard.style.display = 'grid';
                ultimateBoardElement.style.display = 'none';
            }
            
            console.log("startComputerGame: About to call resetGame()...");
            resetGame(); // Initialize board, status, button text/action
            console.log("startComputerGame: Returned from resetGame(). About to call showGameControls()...");
            showGameControls(); // Show correct buttons for AI game
            console.log("startComputerGame: Returned from showGameControls().");
            
            // Computer ('O') might need to make the first move if currentPlayer starts as 'O'
            // Currently, resetGame sets currentPlayer to 'X', so human always starts.
            // If we wanted AI to start sometimes, logic would go here.
            // triggerAIMove(); // Human ('X') starts, so AI waits for human move.
        }

        // === Computer AI Functions ===

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            toggleMode(currentMode); // Initialize based on the default mode ('classic')
            setAIDifficulty(aiDifficulty); // Set initial difficulty UI just in case
        });

        function showModeSelectionScreen() {
            console.log("Executing showModeSelectionScreen..."); // Log entry
            hideAllScreens();
            modeToggleButtons.style.display = 'flex';
            newGameButton.style.display = 'inline-block'; // Show the main action button
            backToModesButton.style.display = 'none'; // Hide back button on main screen
            newGameButton.textContent = 'New Game'; // Reset button text
            newGameButton.onclick = resetGame; // Reset button action
            // Reset special button styles
            document.getElementById('computerMode').style.background = 'rgba(255, 255, 255, 0.1)';
            tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)';
            aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)';
            // Optionally show default rules (e.g., classic)
            document.getElementById('classicRules').classList.add('active');
            // Ensure no game board is visible initially
            classicBoard.style.display = 'none'; 
            ultimateBoardElement.style.display = 'none';
            console.log("showModeSelectionScreen finished."); // Log exit
        }

        function goBackToModes() {
            // Reset game state flags that might persist
            isPlayingAgainstAI = false;
            isTournamentMode = false; // Ensure tournament state is cleared
            currentMode = 'classic'; // Reset mode conceptually
            showModeSelectionScreen();
            // Explicitly reset game state without starting a new visual game
            gameBoard.fill('');
            gameActive = false; // Game is not active on mode screen
            currentPlayer = 'X';
            ultimateBoard = Array(9).fill().map(() => Array(9).fill(''));
            smallBoardWinners.fill('');
            nextBoardIndex = -1;
            clearAllCellTimeouts();
        }

        function showGameControls() {
            // Shows the appropriate main action button (New Game/Change AI/Abandon) and the Back button
            console.log("Executing showGameControls..."); // Log entry
            newGameButton.style.display = 'inline-block';
            backToModesButton.style.display = 'inline-block';
            console.log(`showGameControls: newGameButton display: ${newGameButton.style.display}, backToModesButton display: ${backToModesButton.style.display}`); // Log exit
        }
        // ============================== 

        function toggleTournamentComputerOptions() {
            const type = document.getElementById('player2Type').value;
            const aiOpts = document.getElementById('tournamentComputerOptions');
            const p2Name = document.getElementById('player2Name');
            if (type === 'computer') {
                aiOpts.style.display = 'block';
                p2Name.value = 'Computer';
                p2Name.disabled = true;
            } else {
                aiOpts.style.display = 'none';
                p2Name.value = 'Player 2';
                p2Name.disabled = false;
            }
        }
    </script>
</body>
</html>
