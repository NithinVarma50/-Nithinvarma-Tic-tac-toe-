<head>
    <meta charset="UTF-8">
    <title>Nithin Varma Tic Tac Toe</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Modern Palette */
            --bg-color: #0f172a;
            --surface-color: rgba(30, 41, 59, 0.7);
            --surface-hover: rgba(51, 65, 85, 0.8);
            --primary-gradient: linear-gradient(135deg, #6366f1 0%, #ec4899 100%);
            --secondary-accent: #22d3ee;
            /* Cyan */
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --danger: #ef4444;
            --success: #22c55e;
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background-color: var(--bg-color);
            background-image:
                radial-gradient(at 0% 0%, rgba(99, 102, 241, 0.15) 0px, transparent 50%),
                radial-gradient(at 100% 0%, rgba(236, 72, 153, 0.15) 0px, transparent 50%);
            color: var(--text-primary);
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }

        /* Layout Container */
        .app-container {
            width: 100%;
            max-width: 600px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .title {
            font-size: 2.5rem;
            font-weight: 800;
            text-align: center;
            margin-bottom: 30px;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -1px;
        }

        /* Modern Card Stlying */
        .glass-panel {
            background: var(--surface-color);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: var(--glass-border);
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: var(--glass-shadow);
            width: 100%;
        }

        /* Buttons & Inputs */
        button {
            background: var(--surface-hover);
            border: var(--glass-border);
            color: var(--text-primary);
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }

        button:hover {
            transform: translateY(-2px);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        button.primary {
            background: var(--primary-gradient);
            border: none;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
        }

        button.primary:hover {
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.5);
        }

        input,
        select {
            background: rgba(0, 0, 0, 0.2);
            border: var(--glass-border);
            padding: 12px;
            border-radius: 10px;
            color: white;
            width: 100%;
            outline: none;
            font-family: inherit;
        }

        input:focus,
        select:focus {
            border-color: var(--secondary-accent);
        }

        /* Game Board */
        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            padding: 12px;
            border-radius: 24px;
            background: rgba(0, 0, 0, 0.2);
            width: 100%;
            aspect-ratio: 1;
            /* Square */
            max-width: 400px;
            margin: 0 auto;
        }

        .cell {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .cell:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .cell.x {
            color: #ef4444;
            /* Red/Pink */
            text-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
        }

        .cell.o {
            color: #22d3ee;
            /* Cyan */
            text-shadow: 0 0 15px rgba(34, 211, 238, 0.5);
        }

        /* Ultimate Board Tweaks */
        .ultimate-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 24px;
        }

        .small-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
            padding: 4px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.02);
        }

        .small-board.active {
            box-shadow: 0 0 0 2px var(--secondary-accent);
        }

        .small-cell {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            aspect-ratio: 1;
        }

        /* Status & Roast */
        #status {
            background: rgba(99, 102, 241, 0.1);
            color: var(--secondary-accent);
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: 600;
            margin: 20px 0;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        #roast {
            color: var(--text-secondary);
            font-style: italic;
            min-height: 1.5em;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        /* Mode Selection Grid */
        .mode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            width: 100%;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.05);
            text-align: center;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .mode-btn.active {
            background: var(--primary-gradient);
            border-color: transparent;
        }

        /* Utility */
        .hidden {
            display: none !important;
        }

        .flex-center {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        /* Loading/Animations */
        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        .loader {
            animation: spin 1s linear infinite;
        }

        /* Responsive */
        @media (max-width: 500px) {
            .title {
                font-size: 2rem;
            }

            .board {
                max-width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <h1 class="title">TIC TAC TOE <span style="font-size:0.5em; vertical-align:middle; opacity:0.7">ULTRA</span>
        </h1>

        <!-- Main Game Card -->
        <div class="glass-panel">
            <div id="status">Welcome! Select a mode to start.</div>
            <div id="roast"></div>

            <!-- Mode Selection (Replaces old buttons with Grid) -->
            <div class="mode-toggle mode-grid" id="modeSelector">
                <button onclick="toggleMode('classic')" id="classicMode" class="mode-btn">Classic</button>
                <button onclick="toggleMode('memory')" id="memoryMode" class="mode-btn">Memory</button>
                <button onclick="toggleMode('shuffle')" id="shuffleMode" class="mode-btn">Shuffle</button>
                <button onclick="toggleMode('ultimate')" id="ultimateMode" class="mode-btn">Ultimate</button>
                <button onclick="toggleMode('bolt')" id="boltMode" class="mode-btn">Bolt</button>
                <button onclick="toggleMode('pvp')" id="pvpMode" class="mode-btn"
                    style="border: 1px solid var(--secondary-accent)">PVP Online</button>
                <button onclick="toggleMode('computer')" id="computerMode" class="mode-btn">VS AI</button>
                <button onclick="startTournamentSetup()" id="tournamentModeBtn" class="mode-btn">Tournament</button>
            </div>

            <div style="text-align: center; margin-top: 10px;">
                <button onclick="showAboutScreen()" id="aboutGameBtn"
                    style="background: transparent; border: none; font-size: 0.8em; opacity: 0.6;">About Game</button>
            </div>

            <!-- PVP Setup Screen -->
            <div id="pvpSetupScreen" style="display: none; margin-top: 20px;">
                <h2 style="color: var(--secondary-accent); margin-top: 0;">PVP Online Lounge</h2>
                <div id="pvpInitialOptions">
                    <button onclick="createPVPGame()" class="primary" style="width: 100%; margin-bottom: 10px;">Create
                        Game (Host)</button>
                    <button onclick="showJoinInput()" style="width: 100%;">Join Game</button>
                </div>

                <div id="pvpHostArea" style="display: none;">
                    <p>Share Code:</p>
                    <div id="myPeerId"
                        style="font-size: 2.5em; font-family: monospace; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 12px; margin: 15px 0; border: 1px dashed var(--secondary-accent); color: var(--secondary-accent);">
                        ...</div>
                    <div class="flex-center">
                        <span class="loader"
                            style="width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%;"></span>
                        <span>Waiting for opponent...</span>
                    </div>
                    <button onclick="cancelPVP()" style="margin-top: 20px; width: 100%;">Cancel</button>
                </div>

                <div id="pvpJoinArea" style="display: none;">
                    <input type="text" id="remotePeerIdInput" placeholder="ENTER CODE"
                        style="text-align: center; font-size: 1.5em; letter-spacing: 2px; text-transform: uppercase;">
                    <div class="flex-center" style="margin-top: 15px;">
                        <button onclick="joinPVPGame()" class="primary" style="flex: 1;">Connect</button>
                        <button onclick="cancelPVP()" style="flex: 1;">Back</button>
                    </div>
                </div>
                <div id="pvpStatus" style="color: var(--secondary-accent); margin-top: 15px; font-weight: bold;"></div>
            </div>

            <!-- Tournament Setup Screen -->
            <div id="tournamentSetup"
                style="display: none; background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 8px; margin: 15px 0; width: 90%; max-width: 400px; text-align: center;">
                <h2>Tournament Setup</h2>
                <div>
                    <label for="player1Name">Player 1 (X) Name:</label>
                    <input type="text" id="player1Name" value="Player 1"
                        style="padding: 5px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc;">
                </div>
                <div>
                    <label for="player2Type">Player 2:</label>
                    <select id="player2Type" onchange="toggleTournamentComputerOptions()"
                        style="padding: 5px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc;">
                        <option value="human">Human</option>
                        <option value="computer">Computer</option>
                    </select>
                </div>
                <div id="tournamentComputerOptions" style="display: none; margin-bottom: 10px;">
                    <label for="tournamentAIDifficulty">AI Difficulty:</label>
                    <select id="tournamentAIDifficulty"
                        style="padding: 5px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc;">
                        <option value="easy">Easy</option>
                        <option value="hard" selected>Hard</option>
                        <option value="brutal">Brutal</option>
                    </select>
                </div>
                <div>
                    <label for="player2Name">Player 2 (O) Name:</label>
                    <input type="text" id="player2Name" value="Player 2"
                        style="padding: 5px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc;">
                </div>
                <!-- Optional: Add round selection here later if needed -->
                <button onclick="initializeTournament()">Start Tournament</button>
                <button onclick="exitTournamentSetup()">Cancel</button>
            </div>

            <!-- Computer Game Setup Screen -->
            <div id="computerSetupScreen"
                style="display: none; background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 8px; margin: 15px 0; width: 90%; max-width: 450px; text-align: center;">
                <h2>Play vs Computer Setup</h2>

                <!-- Mode Selection -->
                <div style="margin-bottom: 15px;">
                    <h4>Select Game Mode:</h4>
                    <select id="computerGameMode"
                        style="padding: 8px; margin: 5px 0; border-radius: 4px; border: 1px solid #ccc; width: 80%;">
                        <option value="classic">Classic</option>
                        <option value="memory">Memory</option>
                        <option value="shuffle">Shuffled</option>
                        <option value="ultimate">Ultimate</option>
                        <option value="bolt">Bolt</option> // Added Bolt option
                    </select>
                </div>

                <!-- Difficulty Selection -->
                <div style="margin-bottom: 20px;">
                    <h4>Select Difficulty:</h4>
                    <div style="display: flex; justify-content: center; gap: 10px;">
                        <button onclick="setAIDifficulty('easy')" class="difficulty-btn"
                            data-difficulty="easy">Easy</button>
                        <button onclick="setAIDifficulty('hard')" class="difficulty-btn active"
                            data-difficulty="hard">Hard</button>
                        <button onclick="setAIDifficulty('brutal')" class="difficulty-btn"
                            data-difficulty="brutal">Brutal</button>
                    </div>
                    <input type="hidden" id="aiDifficulty" value="hard"> <!-- Default to hard -->
                </div>

                <button onclick="startComputerGame()">Start Game</button>
                <button onclick="cancelComputerSetup()">Cancel</button>
            </div>

            <!-- Tournament Progress Display -->
            <div id="tournamentProgress"
                style="display: none; background: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0; width: 90%; max-width: 500px; text-align: center;">
                <h3 id="tournamentRoundTitle">Round X: Mode</h3>
                <div style="display: flex; justify-content: space-around; margin-top: 10px; font-size: 1.1em;">
                    <span id="tournamentPlayer1Info">Player 1: 0</span>
                    <span id="tournamentPlayer2Info">Player 2: 0</span>
                </div>
            </div>

            <div id="classicRules" class="rules mode-description active">
                <h3>Classic Game Rules:</h3>
                <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
                    <li>Players take turns placing their mark (X or O) in an empty square.</li>
                    <li>The first player to get three of their marks in a row (up, down, across, or diagonally) is the
                        winner.
                    </li>
                    <li>When all 9 squares are full, the game is over. If no player has 3 marks in a row, the game ends
                        in a
                        draw.</li>
                </ul>
            </div>

            <div id="memoryRules" class="rules mode-description">
                <h3>Memory Mode Rules:</h3>
                <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
                    <li>Each player takes turns placing their mark (X or O) on the grid.</li>
                    <li>Your mark disappears after clicking! Remember your moves!</li>
                    <li>If you click on an already filled box, you lose your turn & get roasted.</li>
                    <li>First player to get three marks in a row, column, or diagonal wins.</li>
                    <li>Once the game ends, all marks will be revealed.</li>
                </ul>
            </div>

            <div id="shuffleRules" class="rules mode-description">
                <h3>Shuffled Mode Rules:</h3>
                <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
                    <li>Everything from the <strong>Memory Mode</strong> applies, BUT...</li>
                    <li>After each turn, the grid slightly shifts position!</li>
                    <li>Your memory will be tested as you track moving cells.</li>
                    <li>Wrong moves still cost you your turn.</li>
                    <li>Are you up for this mind-bending challenge?</li>
                </ul>
            </div>

            <div id="ultimateRules" class="rules mode-description">
                <h3>Ultimate Tic Tac Toe Rules:</h3>
                <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
                    <li>The main board consists of 9 smaller Tic Tac Toe boards in a 3Ã—3 grid.</li>
                    <li>First move can be anywhere on any small board.</li>
                    <li>The position of your move determines which small board your opponent must play in next.</li>
                    <li>Win a small board by getting three in a row within it.</li>
                    <li>Win the game by winning three small boards in a row.</li>
                    <li>If sent to a full or already won board, you can play in any available board.</li>
                </ul>
            </div>

            <!-- New Rules Section for Bolt Mode -->
            <div id="boltRules" class="rules mode-description">
                <h3>Bolt Mode Rules:</h3>
                <ul style="text-align: left; padding: 0 20px; font-size: 0.95em;">
                    <li>Standard Tic-Tac-Toe rules apply (get 3 in a row).</li>
                    <li>Each player can only have a maximum of 3 marks on the board at any given time.</li>
                    <li>When you place your 4th mark, your oldest mark disappears.</li>
                    <li>Plan your moves carefully as the board keeps changing!</li>
                </ul>
            </div>

            <div class="board" id="board">
                <div class="cell" data-index="0"></div>
                <div class="cell" data-index="1"></div>
                <div class="cell" data-index="2"></div>
                <div class="cell" data-index="3"></div>
                <div class="cell" data-index="4"></div>
                <div class="cell" data-index="5"></div>
                <div class="cell" data-index="6"></div>
                <div class="cell" data-index="7"></div>
                <div class="cell" data-index="8"></div>
            </div>

            <div class="ultimate-board" id="ultimateBoard" style="display: none;">
                <!-- 9 small boards, each with 9 cells will be generated by JavaScript -->
            </div>

            <div id="status">Current Player: <span style="color: var(--accent)">X</span></div>
            <div id="roast"></div>
            <button onclick="resetGame()">New Game</button>
            <button id="backToModesBtn" onclick="goBackToModes()" style="display: none; margin-left: 10px;">Back to
                Modes</button>
            <button id="nextRoundBtn" onclick="nextTournamentRound()" style="display: none; margin-left: 10px;">Next
                Round</button>

            <!-- Tournament Results Screen -->
            <div id="tournamentResults"
                style="display: none; background: rgba(42, 42, 114, 0.9); padding: 30px; border-radius: 15px; margin: 20px 0; width: 90%; max-width: 500px; text-align: center; border: 2px solid var(--secondary); box-shadow: 0 0 20px rgba(0, 159, 253, 0.5);">
                <h2 id="tournamentWinner" style="color: gold; font-size: 2em; margin-bottom: 15px;">Champion: Player X
                </h2>
                <h3>Final Score</h3>
                <p id="tournamentFinalScoreP1" style="font-size: 1.2em;">Player 1: X points</p>
                <p id="tournamentFinalScoreP2" style="font-size: 1.2em;">Player 2: Y points</p>
                <!-- Add round summary here later if needed -->
                <div style="margin-top: 25px;">
                    <button onclick="rematchTournament()">Rematch</button>
                    <button onclick="exitTournament()">Back to Modes</button>
                </div>
            </div>

            <!-- About Game Screen -->
            <div id="aboutGameScreen"
                style="display: none; background: rgba(255, 255, 255, 0.1); padding: 20px; border-radius: 8px; margin: 15px 0; width: 90%; max-width: 600px; text-align: left; line-height: 1.6;">
                <h2>About the Game</h2>
                <p>Strategic Tic Tac Toe is a fresh take on the classic game, adding memory challenges and spatial
                    twists that
                    make every round more unpredictable and exciting. With multiple modes and a tournament feature, it's
                    designed for both casual fun and serious face-offs.</p>

                <h3>Game Modes:</h3>
                <ul>
                    <li><strong>Classic Mode</strong><br>
                        The original Tic Tac Toe experience with visible moves and standard rules. A familiar favorite
                        for quick
                        and casual games.</li>
                    <li><strong>Memory Mode</strong> â€“ <em>Concept by Nithin Varma</em><br>
                        A twist where the board is hidden after each turn. Players must remember their moves â€” one
                        mistake can
                        flip the outcome.</li>
                    <li><strong>Shuffled Grid Mode</strong> â€“ <em>Concept by Nithin Varma</em><br>
                        The grid slightly shifts positions after each move, testing your memory and spatial tracking.
                    </li>
                    <li><strong>Ultimate Tic Tac Toe</strong> â€“ <em>Discovered online</em><br>
                        A popular variant where each cell in a 3Ã—3 grid is its own Tic Tac Toe board. While there's no
                        single
                        creator, a widely played version was developed by Michael Xing.</li>
                    <li><strong>Bolt Mode</strong> â€“ <em>A New Strategic Challenge!</em><br>
                        <p>Bolt Mode is a fast-paced variant of Tic-Tac-Toe where marks disappear based on placement
                            order,
                            creating a dynamic and strategic gameplay experience.</p>
                        <strong>How It Works:</strong>
                        <ul>
                            <li><strong>Standard Tic-Tac-Toe Rules:</strong> Players aim to get three in a row just like
                                traditional Tic-Tac-Toe.</li>
                            <li><strong>Limited Marks:</strong> Each player can have a maximum of three marks (X's or
                                O's) on
                                the board at a time.</li>
                            <li><strong>Disappearing Marks:</strong> When a player places their fourth mark, the oldest
                                mark
                                automatically disappears, ensuring only three marks remain on the grid at all times.
                            </li>
                            <li><strong>Strategic Advantage:</strong> Players must carefully plan their moves, as marks
                                disappear over time. This allows new winning opportunities to emerge while also
                                disrupting the
                                opponent's strategy.</li>
                        </ul>
                    </li>
                </ul>

                <h3>Developed By:</h3>
                <p><strong>Nithin Varma</strong></p>

                <button onclick="hideAboutScreen()" style="margin-top: 15px;">Back to Modes</button>
            </div>

            <!-- Firebase SDK (ES Modules) -->
            <script type="module">
                import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
                import { getDatabase, ref, set, onValue, push, remove, child, get, update }
                    from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

                // Firebase Config
                const firebaseConfig = {
                    apiKey: "AIzaSyDGr7NHo1cyOckpu01EyMpYCZq6hxQIae4",
                    authDomain: "tictactoe-a5175.firebaseapp.com",
                    projectId: "tictactoe-a5175",
                    storageBucket: "tictactoe-a5175.firebasestorage.app",
                    messagingSenderId: "699303131940",
                    appId: "1:699303131940:web:312fc17698082cca3451b1",
                    measurementId: "G-NPXRY46ZTN"
                };

                // Initialize Firebase
                const app = initializeApp(firebaseConfig);
                const db = getDatabase(app);

                // PVP Service attached to window for global access
                window.pvpService = {
                    roomId: null,
                    mySide: null, // "X" or "O"
                    gameRef: null,
                    movesRef: null,

                    createGame: async function (mode) {
                        // Generate 4-char ID
                        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
                        let id = "";
                        for (let i = 0; i < 4; i++) id += chars.charAt(Math.floor(Math.random() * chars.length));
                        this.roomId = id;
                        this.mySide = "X";
                        this.gameRef = ref(db, 'games/' + id);
                        this.movesRef = ref(db, 'games/' + id + '/moves');

                        // Initial State
                        await set(this.gameRef, {
                            host: "X",
                            mode: mode,
                            turn: "X", // X always starts
                            state: "waiting",
                            createdAt: Date.now()
                        });

                        // Clear old moves if any (reused ID edge case)
                        await set(this.movesRef, null);

                        this.listenToGame();
                        return id;
                    },

                    joinGame: async function (id) {
                        this.roomId = id;
                        this.gameRef = ref(db, 'games/' + id);
                        this.movesRef = ref(db, 'games/' + id + '/moves');

                        const snapshot = await get(this.gameRef);
                        if (snapshot.exists()) {
                            this.mySide = "O";
                            // Update Guest Presence
                            await update(this.gameRef, {
                                guest: "O",
                                state: "active"
                            });
                            this.listenToGame();
                            return true;
                        } else {
                            return false;
                        }
                    },

                    sendMove: function (data) {
                        if (!this.roomId) return;
                        // Add timestamp for ordering
                        data.timestamp = Date.now();
                        push(this.movesRef, data);
                    },

                    sendReset: function () {
                        if (!this.roomId) return;
                        // We send a reset action as a 'move' or a special flag
                        // Let's use push to 'moves' for simplicity to trigger listener? 
                        // OR update state? peerJS used {type: 'reset'} in data stream.
                        // Let's stick to pushing an action to ensure sequence.
                        push(this.movesRef, { type: 'reset', timestamp: Date.now() });
                    },

                    sendModeChange: function (mode) {
                        if (!this.roomId) return;
                        // Update the mode in the game state directly
                        update(this.gameRef, { mode: mode });
                        // Also push an action so clients know *when* it happened relative to moves?
                        // Actually standard state listener on 'mode' is better.
                    },

                    listenToGame: function () {
                        // Listen for State/Mode Changes
                        onValue(this.gameRef, (snapshot) => {
                            const data = snapshot.val();
                            if (!data) return; // Room deleted

                            // Connection established
                            if (data.guest && data.state === 'active') {
                                // Notify UI that opponent connected
                                if (window.onPVPConnected) window.onPVPConnected();
                            }

                            // Sync Mode
                            if (data.mode && data.mode !== window.currentMode) {
                                if (window.toggleMode) window.toggleMode(data.mode, true);
                            }
                        });

                        // Listen for Moves/Actions
                        // Use 'child_added' to get them in order
                        const movesQuery = this.movesRef;
                        // We could use limitToLast(1) but we want all since join?
                        // Actually getting *new* moves is key. onValue gives all? 
                        // child_added gives previous ones too on init.
                        // We need to handle that or ignore old ones? 
                        // Simplest: Just process them. If index occupied, ignore? 
                        // Better: keep a local "lastProcessedTimestamp".

                        let isInitialLoad = true;
                        // Simple hack: Timer to ignore initial dump? No, risky.
                        // Better: Just execute them. The game state is idempotent-ish.
                        // But processing "reset" again would be bad. 
                        // Standard Firebase pattern: Handle child_added.

                        onValue(this.movesRef, (snapshot) => {
                            const moves = snapshot.val();
                            if (!moves) return;

                            // Sort by timestamp just in case
                            const moveList = Object.values(moves).sort((a, b) => a.timestamp - b.timestamp);

                            // Filter: Only process moves we haven't seen? 
                            // Or just let the existing handlePVPData logic decide? 
                            // PeerJS logic "received" data. 
                            // We need to bridge this.

                            // Problem: onValue triggers on ANY change with ALL data.
                            // We want stream.
                            // Let's use child_added instead?
                        });

                        // Real listener
                        import("https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js").then(mod => {
                            const onChildAdded = mod.onChildAdded;
                            onChildAdded(this.movesRef, (data) => {
                                const move = data.val();
                                // Ignore my own moves? PeerJS logic handled "receive".
                                // In PeerJS I sent to *other*. Here I listen to *all*.
                                // So I will "receive" my own moves too.
                                // My local logic executes my move instantly. 
                                // So I should ignore moves where player === mySide?
                                // EXCEPT for Reset?

                                if (move.player === this.mySide && move.type === 'move') {
                                    return; // Ignore my own echoed move
                                }

                                if (window.handlePVPData) window.handlePVPData(move);
                            });
                        });
                    }
                };
            </script>

            <script>
                // Global Game State (Legacy)
                // PVP State
                // Removed PeerJS vars.
                let isPVPMode = false;
                let myPlayerSide = null; // 'X' or 'O' set by PVPService
                const pvpSetupScreen = document.getElementById('pvpSetupScreen');

                let currentPlayer = 'X';
                let gameBoard = Array(9).fill('');
                let gameActive = true;
                let isPlayingAgainstAI = false; // Flag for AI mode
                let currentMode = 'classic';
                let aiDifficulty = 'hard'; // Add variable for AI difficulty
                let playerXMoves = []; // Track X's moves in order for Bolt mode
                let playerOMoves = []; // Track O's moves in order for Bolt mode
                let isProcessingClick = false; // Flag to prevent rapid click issues

                // Tournament State
                let isTournamentMode = false;
                let isTournamentVsComputer = false; // NEW: Track if tournament is vs computer
                let tournamentAIDifficulty = 'hard'; // NEW: Track AI difficulty for tournament
                let tournamentPlayers = [{ name: 'Player 1', score: 0 }, { name: 'Player 2', score: 0 }];
                let currentTournamentRound = 0; // 0 means not started, 1-based index for rounds
                const tournamentRounds = [
                    { mode: 'classic', points: 1, name: 'Classic' },
                    { mode: 'memory', points: 1, name: 'Memory' },
                    { mode: 'shuffle', points: 1, name: 'Shuffled' },
                    { mode: 'bolt', points: 2, name: 'Bolt' }, // Added Bolt Mode
                    { mode: 'ultimate', points: 2, name: 'Ultimate' }
                ];
                let totalTournamentRounds = tournamentRounds.length;

                // DOM Elements (cache some for performance)
                const statusDisplay = document.getElementById('status');
                const roastDisplay = document.getElementById('roast');
                const classicBoard = document.getElementById('board');
                const ultimateBoardElement = document.getElementById('ultimateBoard');
                const tournamentSetupScreen = document.getElementById('tournamentSetup');
                const tournamentProgressDisplay = document.getElementById('tournamentProgress');
                const tournamentResultsScreen = document.getElementById('tournamentResults');
                const computerSetupScreen = document.getElementById('computerSetupScreen'); // Cache Computer Setup Screen
                const nextRoundButton = document.getElementById('nextRoundBtn');
                const newGameButton = document.querySelector('button[onclick="resetGame()"]');
                const modeToggleButtons = document.querySelector('.mode-toggle');
                const rulesDescriptions = document.querySelectorAll('.rules.mode-description');
                const tournamentModeButton = document.getElementById('tournamentModeBtn'); // Cache button
                const aboutGameButton = document.getElementById('aboutGameBtn');       // Cache button
                const aboutGameScreen = document.getElementById('aboutGameScreen');     // Cache screen
                const backToModesButton = document.getElementById('backToModesBtn');   // Cache Back button

                // For Ultimate Tic Tac Toe
                let ultimateBoard = Array(9).fill().map(() => Array(9).fill(''));
                let smallBoardWinners = Array(9).fill('');
                let nextBoardIndex = -1; // -1 means any board is valid for the next move

                // Store timeout IDs per cell for memory/shuffle modes
                let cellFadeTimeouts = {};
                let cellClearTimeouts = {};

                // Store timeout IDs for animations
                let fadeOutTimeoutId = null;
                let clearCellTimeoutId = null;

                // PVP Functions
                // PVP Functions
                async function createPVPGame() {
                    const selectedMode = document.getElementById('pvpModeSelect').value;
                    // Set mode locally
                    toggleMode(selectedMode);

                    document.getElementById('pvpInitialOptions').style.display = 'none';
                    document.getElementById('pvpHostArea').style.display = 'block';

                    try {
                        const id = await window.pvpService.createGame(selectedMode);
                        document.getElementById('myPeerId').textContent = id;
                        myPlayerSide = "X";
                        // Helper to link UI to Service Listener
                        window.onPVPConnected = () => {
                            document.getElementById('pvpStatus').textContent = "Connected!";
                            startPVPGame();
                        };
                    } catch (err) {
                        console.error(err);
                        document.getElementById('pvpStatus').textContent = "Error creating game: " + err.message;
                    }
                }

                function showJoinInput() {
                    document.getElementById('pvpInitialOptions').style.display = 'none';
                    document.getElementById('pvpJoinArea').style.display = 'block';
                }

                async function joinPVPGame() {
                    const hostId = document.getElementById('remotePeerIdInput').value.trim().toUpperCase();
                    if (!hostId) {
                        document.getElementById('pvpStatus').textContent = "Please enter a code!";
                        return;
                    }

                    document.getElementById('pvpStatus').textContent = "Connecting...";

                    try {
                        const success = await window.pvpService.joinGame(hostId);
                        if (success) {
                            document.getElementById('pvpStatus').textContent = "Connected!";
                            myPlayerSide = "O";
                            startPVPGame();
                        } else {
                            document.getElementById('pvpStatus').textContent = "Game not found!";
                        }
                    } catch (err) {
                        console.error(err);
                        document.getElementById('pvpStatus').textContent = "Connection Failed: " + err.message;
                    }
                }

                // Renamed/Removed setupConnection since logic is in Service

                // This is called by Service listener
                window.handlePVPData = function (data) {
                    console.log("Received PVP Data from Firebase:", data);

                    if (data.type === 'start') {
                        // Legacy PeerJS START. Firebase handles this via presence check.
                    } else if (data.type === 'move') {
                        // Move Sync
                        if (data.player && currentPlayer !== data.player) {
                            console.warn(`Sync: Force turn to ${data.player}`);
                            currentPlayer = data.player;
                            updateStatus();
                        }

                        if (currentMode === 'ultimate') {
                            handleUltimateClick(data.boardIndex, data.cellIndex, true);
                        } else {
                            handleClick(data.index, true);
                        }
                    } else if (data.type === 'reset') {
                        resetGame(true);
                    }
                    // Mode sync handled by 'mode' listener in Service
                }

                function startPVPGame() {
                    isPVPMode = true;
                    document.getElementById('pvpSetupScreen').style.display = 'none';
                    modeToggleButtons.style.display = 'flex';

                    resetGame();
                    updateStatus();
                }

                function cancelPVP() {
                    // No easy 'disconnect' in Firebase without auth? 
                    // Just local reset.
                    resetToMainMenu();
                }

                function resetToMainMenu() {
                    isPVPMode = false;
                    // Clear Service State if needed?
                    window.pvpService.roomId = null;

                    myPlayerSide = null;

                    document.getElementById('pvpInitialOptions').style.display = 'block';
                    document.getElementById('pvpHostArea').style.display = 'none';
                    document.getElementById('pvpJoinArea').style.display = 'none';
                    document.getElementById('pvpSetupScreen').style.display = 'none';
                    document.getElementById('pvpStatus').textContent = "";
                    document.getElementById('remotePeerIdInput').value = "";

                    modeToggleButtons.style.display = 'flex';
                    toggleMode('classic');
                }

                const roasts = [
                    // Light & Playful + Slightly Savage
                    "That spot's taken, genius!",
                    "You really thought that was empty?",
                    "Nice try, but pay attention!",
                    "Clicking randomly won't help!",
                    "Oops! Lost your turn!",
                    "Your memory needs a software update ðŸ§ ðŸ’¾",
                    "Did you think this was a Sudoku puzzle or what?",
                    "Even Google Maps couldn't help you find that spot.", // Adapted slightly
                    "You had one job. ONE. ðŸ˜¤",
                    "That was less Tic Tac Toe, more Tick Tick Oops.", // Adapted slightly
                    "Bro blinked and forgot the whole board.",
                    "I've seen better clicks from a goldfish.", // Adapted slightly
                    "Are you trying to help your opponent?"
                ];

                function showRoast(message) {
                    const roastElement = document.getElementById('roast');
                    roastElement.textContent = message;
                    roastElement.classList.add('roast-visible'); // Trigger animation
                    // Use a longer timeout to ensure text stays visible during fade-out if needed
                    setTimeout(() => {
                        roastElement.classList.remove('roast-visible');
                        // Optional: Clear text after fade-out animation completes
                        // setTimeout(() => roastElement.textContent = '', 300); // Match CSS transition duration
                    }, 2000); // How long the roast stays visible before starting to fade
                }

                function checkWin() {
                    const winPatterns = [
                        [0, 1, 2], [3, 4, 5], [6, 7, 8],
                        [0, 3, 6], [1, 4, 7], [2, 5, 8],
                        [0, 4, 8], [2, 4, 6]
                    ];
                    return winPatterns.find(pattern =>
                        pattern.every(index => gameBoard[index] === currentPlayer)
                    );
                }

                function checkSmallBoardWin(boardIndex) {
                    const winPatterns = [
                        [0, 1, 2], [3, 4, 5], [6, 7, 8],
                        [0, 3, 6], [1, 4, 7], [2, 5, 8],
                        [0, 4, 8], [2, 4, 6]
                    ];

                    return winPatterns.find(pattern =>
                        pattern.every(cellIndex => ultimateBoard[boardIndex][cellIndex] === currentPlayer)
                    );
                }

                function checkUltimateWin() {
                    const winPatterns = [
                        [0, 1, 2], [3, 4, 5], [6, 7, 8],
                        [0, 3, 6], [1, 4, 7], [2, 5, 8],
                        [0, 4, 8], [2, 4, 6]
                    ];

                    return winPatterns.find(pattern =>
                        pattern.every(index => smallBoardWinners[index] === currentPlayer)
                    );
                }

                function checkDraw() {
                    return gameBoard.every(cell => cell !== '');
                }

                function checkUltimateDraw() {
                    // Check if all small boards are either won or full
                    return smallBoardWinners.every((winner, index) => {
                        if (winner !== '') return true; // Board already won
                        return ultimateBoard[index].every(cell => cell !== ''); // Board is full
                    });
                }

                function isSmallBoardFull(boardIndex) {
                    return ultimateBoard[boardIndex].every(cell => cell !== '');
                }

                function toggleMode(mode, fromPeer = false) {
                    console.log(`toggleMode entered. Requested mode: ${mode}. Current mode: ${currentMode}`); // Log entry
                    // Allow re-clicking computer mode to bring up setup if it was somehow hidden
                    if (currentMode === mode && mode !== 'computer') {
                        console.log("toggleMode: Same mode requested, returning.");
                        return;
                    }

                    const previousMode = currentMode; // Store previous mode
                    currentMode = mode; // Update global mode immediately
                    console.log(`toggleMode: Set currentMode to ${currentMode}`);

                    // PVP Sync
                    if (isPVPMode && !fromPeer && window.pvpService.roomId) {
                        window.pvpService.sendModeChange(mode);
                    }

                    // PVP Setup Logic
                    if (currentMode === 'pvp') {
                        classicBoard.style.display = 'none';
                        ultimateBoardElement.style.display = 'none';
                        rulesDescriptions.forEach(el => el.classList.remove('active'));
                        pvpSetupScreen.style.display = 'block';
                        modeToggleButtons.style.display = 'none';
                        return;
                    }

                    // Update UI button styles - Ensure computer button is highlighted correctly
                    document.querySelectorAll('.mode-toggle button').forEach(btn => {
                        let isActive = (btn.id === (currentMode + 'Mode')) || (currentMode === 'computer' && btn.id === 'computerMode') || (currentMode === 'pvp' && btn.id === 'pvpMode');
                        // Handle special case button IDs if they don't follow the pattern
                        if (!document.getElementById(currentMode + 'Mode') && currentMode === 'computer') {
                            isActive = (btn.id === 'computerMode');
                        } // Add similar checks for tournament/about if needed

                        btn.style.background = isActive
                            ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                            : 'rgba(255, 255, 255, 0.1)';
                    });


                    // Handle specific 'computer' mode selection -> Show Setup Screen
                    if (currentMode === 'computer') { // Check the updated currentMode
                        console.log("toggleMode: Condition (currentMode === 'computer') is TRUE. Previous mode was:", previousMode);
                        console.log("toggleMode: Calling showComputerSetupScreen()...");
                        showComputerSetupScreen();
                        console.log("toggleMode: Returned from showComputerSetupScreen(). Executing return; to prevent further setup.");
                        return; // Stop further processing in toggleMode for computer
                    }

                    // --- This part should ONLY run if currentMode is NOT 'computer' --- 
                    console.log("toggleMode: Condition (currentMode === 'computer') is FALSE. Proceeding to setup for mode:", currentMode);
                    // Switching to a non-computer mode (e.g., classic, memory, etc.)
                    isPlayingAgainstAI = false; // Ensure AI is off

                    resetGame();

                    // Update UI
                    document.getElementById('classicMode').style.background = mode === 'classic'
                        ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                        : 'rgba(255, 255, 255, 0.1)';

                    document.getElementById('memoryMode').style.background = mode === 'memory'
                        ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                        : 'rgba(255, 255, 255, 0.1)';

                    document.getElementById('shuffleMode').style.background = mode === 'shuffle'
                        ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                        : 'rgba(255, 255, 255, 0.1)';

                    document.getElementById('ultimateMode').style.background = mode === 'ultimate'
                        ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                        : 'rgba(255, 255, 255, 0.1)';

                    document.getElementById('boltMode').style.background = mode === 'bolt' // Style for Bolt Mode
                        ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                        : 'rgba(255, 255, 255, 0.1)';

                    // Reset AI mode button style unless it's the selected mode
                    document.getElementById('computerMode').style.background = mode === 'computer'
                        ? 'linear-gradient(45deg, var(--primary), var(--secondary))'
                        : 'rgba(255, 255, 255, 0.1)';

                    // Toggle rules visibility
                    // Hide all rules first
                    rulesDescriptions.forEach(el => el.classList.remove('active'));
                    // Show the correct rule description
                    const rulesId = mode + 'Rules';
                    const rulesElement = document.getElementById(rulesId);
                    if (rulesElement) {
                        rulesElement.classList.add('active');
                    } else if (mode === 'computer') {
                        // If computer mode is selected directly (or via setup), show classic rules
                        document.getElementById('classicRules').classList.add('active');
                    }

                    // Toggle board visibility
                    document.getElementById('board').style.display = (mode === 'ultimate') ? 'none' : 'grid'; // Classic board for most modes
                    document.getElementById('ultimateBoard').style.display = mode === 'ultimate' ? 'grid' : 'none';

                    // Add appropriate classes to board
                    const board = document.getElementById('board');
                    board.classList.toggle('shuffle', mode === 'shuffle');

                    // Set AI flag - This will be set by startComputerGame now
                    // isPlayingAgainstAI = (mode === 'computer'); 

                    // Handle specific 'computer' mode selection -> Show Setup Screen
                    if (mode === 'computer') {
                        // Don't immediately start the game. Show the setup screen.
                        showComputerSetupScreen();
                        return; // Stop further processing in toggleMode for computer
                    } else {
                        // Switching to a non-computer mode (e.g., classic, memory, etc.)
                        console.log(`Mode is ${mode}, switching from computer setup or another mode.`);
                        isPlayingAgainstAI = false; // Ensure AI is off
                        cancelComputerSetup(); // Just hide the setup screen if it was visible

                        // Ensure mode buttons are visible (might have been hidden by setup)
                        modeToggleButtons.style.display = 'flex';

                        // Show the correct board for the selected non-computer mode
                        if (currentMode === 'ultimate') {
                            classicBoard.style.display = 'none';
                            ultimateBoardElement.style.display = 'grid';
                        } else {
                            ultimateBoardElement.style.display = 'none';
                            classicBoard.style.display = 'grid';
                        }

                        // Show appropriate rules
                        rulesDescriptions.forEach(el => el.classList.remove('active'));
                        const rulesId = currentMode + 'Rules';
                        const rulesElement = document.getElementById(rulesId);
                        if (rulesElement) { rulesElement.classList.add('active'); }

                        // Reset game state and show controls
                        resetGame(); // Reset board state for the new mode. resetGame calls updateStatus.
                        showGameControls(); // Show New Game/Back buttons
                        statusDisplay.style.display = 'block'; // Ensure status is visible
                        roastDisplay.style.display = 'block';  // Ensure roast is visible
                    }

                    // If NOT in tournament mode, ensure standard UI elements are visible
                    if (!isTournamentMode) {
                        statusDisplay.style.display = 'block';
                        roastDisplay.style.display = 'block';
                        newGameButton.style.display = 'inline-block';
                        nextRoundButton.style.display = 'none'; // Ensure hidden outside tournament
                    }

                    // For Ultimate mode, make sure the board is initialized
                    if (mode === 'ultimate') {
                        initializeUltimateBoard();
                    }

                    document.getElementById('board').style.transform = 'none';
                    document.getElementById('roast').classList.remove('roast-visible'); // Hide roast

                    // Update status display
                    updateStatus(); // Moved updateStatus call here to reflect changes immediately
                }

                function initializeUltimateBoard() {
                    const ultimateBoardElement = document.getElementById('ultimateBoard');
                    ultimateBoardElement.innerHTML = '';

                    // Create 9 small boards
                    for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                        const smallBoard = document.createElement('div');
                        smallBoard.className = 'small-board';
                        smallBoard.dataset.boardIndex = boardIndex;
                        smallBoard.style.position = 'relative';

                        // Create 9 cells for each small board
                        for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                            const cell = document.createElement('div');
                            cell.className = 'small-cell';
                            cell.dataset.boardIndex = boardIndex;
                            cell.dataset.cellIndex = cellIndex;

                            cell.addEventListener('click', () => handleUltimateClick(boardIndex, cellIndex));

                            smallBoard.appendChild(cell);
                        }

                        ultimateBoardElement.appendChild(smallBoard);
                    }

                    updateUltimateUI();
                }

                function updateUltimateUI() {
                    // Update all cells based on ultimateBoard array
                    document.querySelectorAll('.small-cell').forEach(cell => {
                        const boardIndex = parseInt(cell.dataset.boardIndex);
                        const cellIndex = parseInt(cell.dataset.cellIndex);
                        const value = ultimateBoard[boardIndex][cellIndex];

                        cell.textContent = value;
                        cell.className = 'small-cell';
                        if (value === 'X') cell.classList.add('x');
                        if (value === 'O') cell.classList.add('o');
                    });

                    // Update small board states
                    document.querySelectorAll('.small-board').forEach(board => {
                        const boardIndex = parseInt(board.dataset.boardIndex);

                        // Clear previous classes and remove existing markers first
                        const existingMarker = board.querySelector('.board-win-marker');
                        if (existingMarker) {
                            existingMarker.remove();
                        }
                        board.className = 'small-board'; // Reset classes

                        // Add active class if this is the next board to play in
                        if (gameActive && (nextBoardIndex === boardIndex || (nextBoardIndex === -1 && smallBoardWinners[boardIndex] === '' && !isSmallBoardFull(boardIndex)))) {
                            board.classList.add('active');
                        }

                        // Add won class if this board has been won
                        if (smallBoardWinners[boardIndex] === 'X') {
                            board.classList.add('won-x');

                            // If there's no win marker yet, add one
                            if (!board.querySelector('.board-win-marker')) {
                                const marker = document.createElement('div');
                                marker.className = 'board-win-marker';
                                marker.textContent = 'X';
                                board.appendChild(marker);
                            }
                        } else if (smallBoardWinners[boardIndex] === 'O') {
                            board.classList.add('won-o');

                            // If there's no win marker yet, add one
                            if (!board.querySelector('.board-win-marker')) {
                                const marker = document.createElement('div');
                                marker.className = 'board-win-marker';
                                marker.textContent = 'O';
                                board.appendChild(marker);
                            }
                        }
                    });

                    document.querySelectorAll('.small-board').forEach(board => {
                        board.classList.remove('ultimate-win'); // Remove ultimate win highlight
                    });

                    document.getElementById('board').style.transform = 'none';
                    document.getElementById('roast').classList.remove('roast-visible'); // Hide roast
                }

                function handleUltimateClick(boardIndex, cellIndex, fromPeer = false) {
                    console.log(`handleUltimateClick called: board=${boardIndex}, cell=${cellIndex}. Current player: ${currentPlayer}. AI Mode: ${isPlayingAgainstAI}`); // Log entry
                    if (!gameActive) return;

                    // PVP Check
                    if (isPVPMode && !fromPeer) {
                        if (currentPlayer !== myPlayerSide) {
                            showRoast("Wait for your turn!");
                            return;
                        }
                    }

                    // Check if this is a valid move
                    // Either nextBoardIndex is -1 (any board) or matches the current boardIndex
                    // And the board must not be already won
                    // And the cell must be empty
                    if ((nextBoardIndex === -1 || nextBoardIndex === boardIndex) &&
                        smallBoardWinners[boardIndex] === '' &&
                        ultimateBoard[boardIndex][cellIndex] === '') {

                        // PVP: Send move
                        if (isPVPMode && !fromPeer && window.pvpService.roomId) {
                            window.pvpService.sendMove({ type: 'move', boardIndex: boardIndex, cellIndex: cellIndex, player: currentPlayer });
                        }

                        // Make the move
                        ultimateBoard[boardIndex][cellIndex] = currentPlayer;
                        const cellElement = document.querySelector(`.small-cell[data-board-index="${boardIndex}"][data-cell-index="${cellIndex}"]`);
                        cellElement.classList.add('popping'); // Add pop animation
                        cellElement.addEventListener('animationend', () => cellElement.classList.remove('popping'), { once: true }); // Remove class after animation

                        let justWonSmallBoard = false;
                        // Check if this move wins the small board
                        if (smallBoardWinners[boardIndex] === '' && checkSmallBoardWin(boardIndex)) {
                            smallBoardWinners[boardIndex] = currentPlayer;
                            justWonSmallBoard = true; // Mark that this move won the small board

                            // Check if this wins the entire game
                            const winningPattern = checkUltimateWin();
                            if (winningPattern) {
                                gameActive = false;
                                updateUltimateUI(); // Update UI to show the last small board win marker
                                visualizeUltimateWin(winningPattern); // Highlight the winning boards
                                // Tournament Mode Check
                                if (isTournamentMode) {
                                    handleTournamentGameEnd(currentPlayer);
                                } else {
                                    document.getElementById('status').textContent = `Player ${currentPlayer} wins the game!`;
                                }
                                return; // Game Over
                            }
                        }

                        // Check for a draw (only if the game isn't already won)
                        if (checkUltimateDraw()) {
                            gameActive = false;
                            // Tournament Mode Check
                            if (isTournamentMode) {
                                handleTournamentGameEnd('Draw');
                            } else {
                                document.getElementById('status').textContent = "It's a Draw!";
                            }
                            updateUltimateUI(); // Update UI one last time for draw
                            return;
                        }

                        // Set the next board based on the cell played
                        nextBoardIndex = cellIndex;

                        // If the next board is already won or full, player can choose any board
                        if (smallBoardWinners[nextBoardIndex] !== '' || isSmallBoardFull(nextBoardIndex)) {
                            nextBoardIndex = -1;
                        }

                        // Switch players
                        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                        updateStatus();
                        console.log(`handleUltimateClick: Player switched to ${currentPlayer}. Next board target: ${nextBoardIndex}`); // Log player switch

                        // Update the UI
                        updateUltimateUI();
                        // Trigger AI move if applicable AFTER UI update and player switch
                        // If in tournament vs computer, only trigger AI if it's O's turn
                        if (isTournamentVsComputer && currentPlayer === 'O' && gameActive) {
                            triggerAIMove();
                        } else if (!isTournamentVsComputer) {
                            triggerAIMove();
                        }

                    } else if (ultimateBoard[boardIndex][cellIndex] !== '') {
                        showRoast(roasts[Math.floor(Math.random() * roasts.length)]);
                    } else if (smallBoardWinners[boardIndex] !== '' || isSmallBoardFull(boardIndex)) {
                        // If the click was invalid because the small board was already won/full
                        // but the click was otherwise in a valid *location* if nextBoardIndex was -1
                        showRoast("This small board is already complete!");
                    } else {
                        showRoast("You must play in the highlighted board!");
                    }
                }

                function shuffleBoard() {
                    if (currentMode !== 'shuffle') return;
                    const board = document.getElementById('board');
                    const randomX = (Math.random() - 0.5) * 20;
                    const randomY = (Math.random() - 0.5) * 20;
                    const randomRotate = (Math.random() - 0.5) * 5;
                    board.style.transform = `translate(${randomX}px, ${randomY}px) rotate(${randomRotate}deg)`;
                }

                function handleClick(index, fromPeer = false) {
                    // Prevent processing if already handling a click (ONLY for local clicks)
                    // Remote moves must always proceed or queue, otherwise we get desync.
                    if (isProcessingClick && !fromPeer) {
                        console.log("Rapid click detected, ignoring.");
                        return;
                    }

                    // PVP Check: If it's PVP mode, not from peer, and not my turn -> Block
                    if (isPVPMode && !fromPeer) {
                        if (currentPlayer !== myPlayerSide) {
                            showRoast("Wait for your turn!");
                            return;
                        }
                    }

                    // Lock the function
                    isProcessingClick = true;
                    // Add log to show state at start of handle click
                    console.log(`handleClick Start: Index ${index}, Player ${currentPlayer}. Bolt Moves X: ${JSON.stringify(playerXMoves)}, O: ${JSON.stringify(playerOMoves)}`);

                    try {
                        if (!gameActive || gameBoard[index] !== '') { // Check if game active AND cell is empty
                            // Handle invalid move (roast, switch turn for memory/shuffle, etc.)
                            if (gameBoard[index] !== '' && (currentMode === 'memory' || currentMode === 'shuffle')) {
                                // In PVP, invalid moves should not switch turns locally for the clicker if it's just a roast
                                // But for Memory/Shuffle, a wrong click normally switches turns.
                                // For PVP simplicity, let's keep it syncing BUT we need to tell the other peer IF the turn switches.
                                // However, syncing invalid moves is complex. Let's block turn switching for invalid moves in PVP Memory/Shuffle for now or handle it carefully.
                                // Decision: Allow local roast but maybe don't switch turn in PVP to avoid desync if packet lost? 
                                // Better: If it causes turn switch, we MUST sync it. PeerJS logic handles 'move' which implies successful placement.
                                // We might need a special 'turnSwitch' event if no move is made. 
                                // For now: Stick to standard. If not from peer, we execute logic. If turn switches, how does peer know?
                                // Peer receives 'move' data only on successful placement in standard logic.
                                // If we switch turn here without placement, we need to send a 'skip' or 'foul' event.

                                showRoast(roasts[Math.floor(Math.random() * roasts.length)]);

                                if (!isPVPMode) { // PVP: Don't switch turn on foul for simplicity to avoid desync
                                    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                                    updateStatus();
                                    if (currentMode === 'shuffle') shuffleBoard();
                                } else {
                                    // In PVP, maybe just roast and keep turn?
                                    // Yes, keeps it simple. No turn switch on memory/shuffle errors in PVP.
                                }

                                console.log("handleClick (Memory/Shuffle - invalid move): Player lost turn (or just roasted).");
                            } else if (gameBoard[index] !== '' && currentMode === 'bolt') {
                                // Log the specific invalid move case for Bolt
                                console.log(`handleClick Bolt: Invalid move on occupied cell ${index}. Cell contains: ${gameBoard[index]}. Showing roast.`);
                                showRoast("Oops! That spot is taken.");
                            } else if (!gameActive) {
                                console.log(`handleClick: Invalid move on cell ${index}. Game not active.`);
                            } else {
                                // Catch-all for other invalid clicks (e.g., classic mode on occupied cell)
                                console.log(`handleClick: Invalid move on occupied cell ${index} in ${currentMode} mode. Cell contains: ${gameBoard[index]}.`);
                            }

                            // Crucial return check for occupied cells in non-memory/shuffle modes
                            if (!gameActive) {
                                console.log("handleClick: Game not active, returning.");
                                return;
                            }
                            if (gameBoard[index] !== '' && (currentMode !== 'memory' && currentMode !== 'shuffle')) {
                                // Log before returning due to occupied cell in Bolt/Classic/AI
                                console.log(`handleClick: Cell ${index} occupied in ${currentMode} mode. Returning before placing mark.`);
                                return;
                            }
                            // If we reach here, it must be a memory/shuffle invalid click where the player was switched (or not in PVP), so we proceed.
                            console.log(`handleClick: Invalid move logic complete for memory/shuffle on cell ${index}. Proceeding to finally.`);

                        } else { // --- Valid Move --- Only execute if cell was empty and game active

                            // PVP: Send move to peer if valid and local
                            if (isPVPMode && !fromPeer && window.pvpService.roomId) {
                                window.pvpService.sendMove({ type: 'move', index: index, player: currentPlayer });
                            }

                            const cell = document.querySelector(`[data-index="${index}"]`);

                            // Bolt Mode: Check for oldest mark removal BEFORE placing the new one
                            if (currentMode === 'bolt') {
                                let playerMoves = (currentPlayer === 'X') ? playerXMoves : playerOMoves;
                                console.log(`Bolt Mode Check: Player ${currentPlayer}, Moves: ${JSON.stringify(playerMoves)}, Length: ${playerMoves.length}`); // Log state before check

                                if (playerMoves.length === 3) { // Check if player *already* has 3 marks
                                    console.log(`Bolt Mode Action: Player ${currentPlayer} has 3 marks. Removing oldest.`); // Log action
                                    const oldestMoveIndex = playerMoves.shift(); // Get and remove oldest index from tracking array
                                    console.log(`Bolt Mode Action: Oldest index to remove: ${oldestMoveIndex}`); // Log index
                                    gameBoard[oldestMoveIndex] = ''; // Remove from game board state
                                    const oldestCell = document.querySelector(`[data-index="${oldestMoveIndex}"]`);
                                    if (oldestCell) {
                                        console.log(`Bolt Mode Action: Clearing cell ${oldestMoveIndex} visually.`); // Log visual clear
                                        oldestCell.textContent = ''; // Clear visual mark
                                        oldestCell.classList.remove('x', 'o');
                                    } else {
                                        console.error(`Bolt Mode Error: Could not find cell with index ${oldestMoveIndex} to remove mark.`);
                                    }
                                } else {
                                    console.log(`Bolt Mode Check: Player ${currentPlayer} has < 3 marks (${playerMoves.length}). No removal needed.`); // Log no removal
                                }
                            }

                            // Place the new mark logically and visually
                            console.log(`Bolt Mode: Placing mark ${currentPlayer} at index ${index}.`); // Log placement
                            gameBoard[index] = currentPlayer;
                            if (currentMode === 'memory' || currentMode === 'shuffle') {
                                const cellContent = document.createElement('div');
                                cellContent.className = 'cell-content';
                                cellContent.textContent = currentPlayer;
                                cell.innerHTML = ''; // Clear previous content
                                cell.appendChild(cellContent);
                                cell.classList.add(currentPlayer.toLowerCase());
                                cellFadeTimeouts[index] = setTimeout(() => {
                                    cellContent.classList.add('fade-out');
                                    cellClearTimeouts[index] = setTimeout(() => {
                                        const currentCellContent = cell.querySelector('.cell-content');
                                        if (currentCellContent) { cell.innerHTML = ''; }
                                    }, 300);
                                }, 400);
                            } else {
                                cell.textContent = currentPlayer;
                                cell.classList.add(currentPlayer.toLowerCase());
                            }

                            // Add popping animation
                            cell.classList.add('popping');
                            cell.addEventListener('animationend', () => cell.classList.remove('popping'), { once: true });

                            // Bolt Mode: Add the new move index AFTER placing the mark and removing the old one (if applicable)
                            if (currentMode === 'bolt') {
                                let playerMoves = (currentPlayer === 'X') ? playerXMoves : playerOMoves;
                                playerMoves.push(index); // Add the new move index to the tracking array
                                console.log(`Bolt Mode Update: Added index ${index} for ${currentPlayer}. New Moves: ${JSON.stringify(playerMoves)}, New Length: ${playerMoves.length}`);
                            }

                            // --- Check for Win/Draw ---
                            const winningPattern = checkWin();
                            if (winningPattern) {
                                gameActive = false;
                                clearAllCellTimeouts();
                                if (currentMode === 'shuffle' || currentMode === 'bolt') {
                                    document.getElementById('board').style.transform = 'none';
                                }
                                revealBoard(winningPattern);
                                if (isTournamentMode) {
                                    handleTournamentGameEnd(currentPlayer);
                                } else {
                                    document.getElementById('status').textContent = `Player ${currentPlayer} wins!`;
                                }
                                return; // Exit after win
                            }

                            if (checkDraw()) {
                                gameActive = false;
                                clearAllCellTimeouts();
                                if (currentMode === 'shuffle' || currentMode === 'bolt') {
                                    document.getElementById('board').style.transform = 'none';
                                }
                                revealBoard();
                                if (isTournamentMode) {
                                    handleTournamentGameEnd('Draw');
                                } else {
                                    document.getElementById('status').textContent = "It's a Draw!";
                                }
                                return; // Exit after draw
                            }

                            // --- Switch Player and Trigger AI/Shuffle ---
                            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                            updateStatus();

                            if (currentMode === 'shuffle') shuffleBoard();
                        } // End of valid move block

                    } finally {
                        // Unlock the function
                        isProcessingClick = false;
                        console.log(`handleClick End: Releasing lock. Player is now ${currentPlayer}.`);

                        // Trigger AI move *after* the lock is released and player has been potentially switched
                        // This check needs to be outside the 'valid move' block to handle AI trigger after invalid memory/shuffle moves too.
                        console.log(`handleClick Finally: Checking for AI trigger. isAI=${isPlayingAgainstAI}, current=${currentPlayer}, active=${gameActive}`);
                        // If in tournament vs computer, only trigger AI if it's O's turn
                        if (isTournamentVsComputer && currentPlayer === 'O' && gameActive) {
                            triggerAIMove();
                        } else if (!isTournamentVsComputer) {
                            triggerAIMove();
                        }
                    }
                }

                function revealBoard(winningPattern = null) {
                    document.querySelectorAll('.cell').forEach((cell, index) => {
                        // Ensure the cell content is visible and correct class is applied
                        cell.innerHTML = ''; // Clear any potential animated divs
                        cell.textContent = gameBoard[index];
                        cell.classList.remove('x', 'o', 'winning-cell'); // Remove old classes first, including win highlight
                        if (gameBoard[index] === 'X') {
                            cell.classList.add('x');
                        } else if (gameBoard[index] === 'O') {
                            cell.classList.add('o');
                        }

                        // Add winning cell highlight if applicable
                        if (winningPattern && winningPattern.includes(index)) {
                            cell.classList.add('winning-cell');
                        }
                    });

                    // If playing against AI, trigger AI's turn after human moves
                    triggerAIMove();
                }

                function updateStatus() {
                    let statusText = "";
                    const playerColor = currentPlayer === 'X' ? 'var(--accent)' : '#2ecc71';

                    if (isTournamentMode) {
                        const currentPlayerName = currentPlayer === 'X' ? tournamentPlayers[0].name : tournamentPlayers[1].name;
                        statusText = `Current Player: ${currentPlayerName} (<span style="color: ${playerColor}">${currentPlayer}</span>)`;
                    } else if (isPVPMode) {
                        // PVP Status
                        const myRole = (myPlayerSide === 'X') ? 'Host' : 'Guest';
                        const opponentRole = (myPlayerSide === 'X') ? 'Guest' : 'Host';
                        const turnText = (currentPlayer === myPlayerSide) ? "Your Turn" : "Opponent's Turn";
                        statusText = `${turnText} (${currentPlayer}) - You are ${myPlayerSide} (${myRole})`;
                    } else if (isPlayingAgainstAI) {
                        const difficultyDisplay = aiDifficulty.charAt(0).toUpperCase() + aiDifficulty.slice(1);
                        const modeDisplay = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
                        if (currentPlayer === 'X') {
                            statusText = `Your Turn (<span style="color: ${playerColor}">X</span>) vs Computer (${modeDisplay} [${difficultyDisplay}])`;
                        } else {
                            statusText = `Computer's Turn (<span style="color: ${playerColor}">O</span>) (${modeDisplay} [${difficultyDisplay}])`;
                        }
                    } else {
                        statusText = `Current Player: <span style="color: ${playerColor}">${currentPlayer}</span>`;
                    }

                    // Append Ultimate mode specific info if applicable
                    if (currentMode === 'ultimate' && gameActive) {
                        if (nextBoardIndex === -1) {
                            statusText += ' - Play in any available board';
                        } else {
                            statusText += ` - Play in board ${nextBoardIndex + 1}`;
                        }
                    }

                    statusDisplay.innerHTML = statusText;
                }

                function resetGame(fromPeer = false) {
                    console.log(`Executing resetGame... isPlayingAgainstAI: ${isPlayingAgainstAI}, isTournamentMode: ${isTournamentMode}`); // Log entry with state

                    // PVP Sync
                    if (isPVPMode && !fromPeer && window.pvpService.roomId) {
                        window.pvpService.sendReset();
                    }

                    gameBoard.fill('');
                    gameActive = true;
                    currentPlayer = 'X';

                    // Reset Ultimate Tic Tac Toe state
                    ultimateBoard = Array(9).fill().map(() => Array(9).fill(''));
                    smallBoardWinners = Array(9).fill('');
                    nextBoardIndex = -1;

                    // Clear all pending cell timeouts on reset
                    clearAllCellTimeouts();
                    console.log("resetGame finished."); // Log exit

                    // Reset Bolt mode move tracking
                    playerXMoves = [];
                    playerOMoves = [];
                    // Add log to confirm reset
                    console.log(`resetGame: Cleared Bolt moves. X: ${JSON.stringify(playerXMoves)}, O: ${JSON.stringify(playerOMoves)}`);

                    // Reset UI
                    document.querySelectorAll('.cell').forEach(cell => {
                        cell.textContent = '';
                        cell.className = 'cell'; // Remove any added classes
                    });

                    // Update Ultimate board if that's the current mode
                    if (currentMode === 'ultimate') {
                        // Ensure ultimate board is reset and displayed correctly
                        initializeUltimateBoard();
                    }

                    // Update status, but only if not in tournament mode OR if called explicitly
                    // During tournament round start, status is updated separately
                    if (!isTournamentMode) {
                        updateStatus();
                    } else if (isPlayingAgainstAI) {
                        // If starting an AI game (maybe from a tournament mode later?)
                        updateStatus();
                    } else {
                        // In tournament mode, resetGame is called by toggleMode when starting a round.
                        // We need to ensure the status display reflects the current tournament player.
                        updateStatus();
                    }

                    // Update status and buttons based on game state (AI, tournament, or normal)
                    updateStatus(); // Always update status first

                    // Reset button text/action based on whether AI mode is active
                    if (isPlayingAgainstAI) {
                        newGameButton.textContent = 'Change AI Settings';
                        newGameButton.onclick = showComputerSetupScreen; // Go back to setup
                        backToModesButton.style.display = 'inline-block';
                        console.log("resetGame (AI branch): Set back button display to inline-block");
                    } else if (isTournamentMode) {
                        // In tournament, button text/action is set elsewhere (initializeTournament, startTournamentRound)
                        newGameButton.textContent = 'Abandon Tournament'; // Make sure this is set if reset is called mid-tournament
                        newGameButton.onclick = confirmAbandonTournament;
                        backToModesButton.style.display = 'none'; // Explicitly hide in tournament
                        console.log("resetGame (Tournament branch): Hid back button");
                    } else {
                        // Standard non-AI, non-tournament game
                        newGameButton.textContent = 'New Game';
                        newGameButton.onclick = resetGame; // Standard reset
                        backToModesButton.style.display = 'inline-block';
                        console.log("resetGame (Standard branch): Set back button display to inline-block");
                    }

                    // Clear all pending cell timeouts on reset
                    clearAllCellTimeouts();
                }

                function visualizeUltimateWin(winningPattern) {
                    winningPattern.forEach(boardIndex => {
                        const boardElement = document.querySelector(`.small-board[data-board-index="${boardIndex}"]`);
                        // Remove previous state classes before adding the ultimate win class
                        boardElement.classList.remove('won-x', 'won-o', 'active');
                        if (boardElement) {
                            boardElement.classList.add('ultimate-win');
                        }
                    });
                }

                function clearAllCellTimeouts() {
                    Object.values(cellFadeTimeouts).forEach(clearTimeout);
                    Object.values(cellClearTimeouts).forEach(clearTimeout);
                    cellFadeTimeouts = {};
                    cellClearTimeouts = {};
                }

                function triggerAIMove() {
                    console.log(`triggerAIMove called. Conditions: isAI=${isPlayingAgainstAI}, player=${currentPlayer}, active=${gameActive}, mode=${currentMode}`);
                    if (isPlayingAgainstAI && currentPlayer === 'O' && gameActive) {

                        // Select correct board based on mode
                        const targetBoard = currentMode === 'ultimate' ? ultimateBoardElement : classicBoard;
                        targetBoard.style.pointerEvents = 'none'; // Disable player clicks

                        console.log(`AI Turn triggered (Mode: ${currentMode}, Difficulty: ${aiDifficulty}). Setting timeout.`);

                        setTimeout(() => {
                            console.log('AI Timeout: Calculating move...');
                            let aiMove = null;

                            if (currentMode === 'ultimate') {
                                console.log(`AI Timeout: Current player ${currentPlayer}, nextBoardIndex: ${nextBoardIndex}`); // Log state before move calc
                                aiMove = makeUltimateAIMove(aiDifficulty);
                                console.log(`AI Timeout: makeUltimateAIMove returned: ${JSON.stringify(aiMove)}`); // Log the returned object
                                if (aiMove && typeof aiMove.boardIndex !== 'undefined' && typeof aiMove.cellIndex !== 'undefined') {
                                    console.log(`AI Timeout: Valid move object received. Calling handleUltimateClick(${aiMove.boardIndex}, ${aiMove.cellIndex})`);
                                    handleUltimateClick(aiMove.boardIndex, aiMove.cellIndex); // AI makes its ultimate move
                                } else {
                                    console.log('AI Timeout: Ultimate AI move index is null, cannot play.');
                                }
                            } else {
                                // Classic, Memory, Shuffle modes
                                aiMove = makeAIMove(aiDifficulty);
                                console.log(`AI Timeout: makeAIMove returned: ${aiMove}`);
                                if (aiMove !== null) {
                                    console.log(`AI Timeout: Calling handleClick(${aiMove})`);
                                    handleClick(aiMove); // AI makes its classic/memory/shuffle move
                                } else {
                                    console.log('AI Timeout: Classic AI move index is null, cannot play.');
                                }
                            }

                            targetBoard.style.pointerEvents = 'auto'; // Re-enable player clicks
                        }, 600); // 600ms delay
                    } else {
                        console.log('AI Turn conditions not met or not AI turn.');
                    }
                }

                function makeAIMove(difficulty) {
                    console.log(`Calculating AI move for 3x3 board. Difficulty: ${difficulty}`);
                    const aiPlayer = 'O';
                    const humanPlayer = 'X';
                    let board = [...gameBoard]; // Use the internal game board state
                    const availableMoves = board.map((val, idx) => val === '' ? idx : null).filter(val => val !== null);

                    if (availableMoves.length === 0) return null; // No moves possible

                    // Difficulty: Easy -> ~50% chance of random move, otherwise proceed to Hard logic
                    if (difficulty === 'easy' && Math.random() < 0.5) {
                        console.log("AI Easy: Making random move");
                        return availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    }

                    // Difficulty: Brutal (Placeholder - for now, same as Hard)
                    // TODO: Implement Minimax for Brutal difficulty
                    if (difficulty === 'brutal') {
                        console.log("AI Brutal: Using Hard logic (Minimax TODO)");
                        // Fallthrough to Hard logic for now
                    }

                    // --- Hard Logic (and fallback for Easy/Brutal) ---
                    console.log("AI Hard: Evaluating strategic moves...");

                    // Helper to check if a move is winning for a player
                    const isWinningMove = (player, index) => {
                        if (board[index] !== '') return false;
                        board[index] = player; // Temporarily make the move
                        const win = checkWinInternal(board, player); // Check win with temp board
                        board[index] = ''; // Undo the move
                        return win;
                    };

                    // Helper to check for wins based on a specific board state
                    const checkWinInternal = (currentBoard, player) => {
                        const winPatterns = [
                            [0, 1, 2], [3, 4, 5], [6, 7, 8],
                            [0, 3, 6], [1, 4, 7], [2, 5, 8],
                            [0, 4, 8], [2, 4, 6]
                        ];
                        return winPatterns.some(pattern =>
                            pattern.every(idx => currentBoard[idx] === player)
                        );
                    };

                    // 1. Check if AI can win in the next move
                    for (let i = 0; i < 9; i++) {
                        if (isWinningMove(aiPlayer, i)) {
                            return i;
                        }
                    }

                    // 2. Check if human can win in the next move, and block them
                    for (let i = 0; i < 9; i++) {
                        if (isWinningMove(humanPlayer, i)) {
                            return i;
                        }
                    }

                    // 3. Try to take the center if it's free
                    if (board[4] === '') {
                        return 4;
                    }

                    // 4. Try to take opposite corner (if player took a corner)
                    const corners = [0, 2, 6, 8];
                    const oppositeCorners = { 0: 8, 2: 6, 6: 2, 8: 0 };
                    for (const corner of corners) {
                        if (board[corner] === humanPlayer && board[oppositeCorners[corner]] === '') {
                            return oppositeCorners[corner];
                        }
                    }

                    // 5. Try to take any empty corner
                    const emptyCorners = corners.filter(i => board[i] === '');
                    if (emptyCorners.length > 0) {
                        return emptyCorners[Math.floor(Math.random() * emptyCorners.length)]; // Pick random empty corner
                    }

                    // 6. Try to take any empty side
                    const sides = [1, 3, 5, 7];
                    const emptySides = sides.filter(i => board[i] === '');
                    if (emptySides.length > 0) {
                        return emptySides[Math.floor(Math.random() * emptySides.length)]; // Pick random empty side
                    }

                    // Should not happen in Tic Tac Toe if logic is correct, but fallback
                    return availableMoves.length > 0 ? availableMoves[Math.floor(Math.random() * availableMoves.length)] : null;
                }

                function makeUltimateAIMove(difficulty) {
                    console.log(`Calculating AI move for Ultimate board. Difficulty: ${difficulty}, Next Board: ${nextBoardIndex}`);
                    const aiPlayer = 'O';
                    const humanPlayer = 'X';

                    let possibleMoves = [];

                    // Determine valid boards to play in
                    let validBoardIndices = [];
                    if (nextBoardIndex === -1) {
                        // Can play in any board that isn't won or full
                        for (let i = 0; i < 9; i++) {
                            if (smallBoardWinners[i] === '' && !isSmallBoardFull(i)) {
                                validBoardIndices.push(i);
                            }
                        }
                    } else if (smallBoardWinners[nextBoardIndex] === '' && !isSmallBoardFull(nextBoardIndex)) {
                        // Must play in the specified board
                        validBoardIndices.push(nextBoardIndex);
                    } else {
                        // Sent to a finished board, can play anywhere else that's valid
                        for (let i = 0; i < 9; i++) {
                            if (smallBoardWinners[i] === '' && !isSmallBoardFull(i)) {
                                validBoardIndices.push(i);
                            }
                        }
                    }

                    if (validBoardIndices.length === 0) {
                        console.log("Ultimate AI: No valid boards to play in! Returning null.");
                        return null; // No moves possible
                    }
                    console.log("Ultimate AI: Valid boards to play in:", validBoardIndices);

                    // Find all available cells within the valid boards
                    validBoardIndices.forEach(boardIdx => {
                        for (let cellIdx = 0; cellIdx < 9; cellIdx++) {
                            if (ultimateBoard[boardIdx][cellIdx] === '') {
                                possibleMoves.push({ boardIndex: boardIdx, cellIndex: cellIdx });
                            }
                        }
                    });

                    if (possibleMoves.length === 0) {
                        console.log("Ultimate AI: No empty cells in valid boards! Returning null.");
                        return null; // Should not happen if validBoardIndices has boards
                    }
                    console.log(`Ultimate AI: Found ${possibleMoves.length} possible moves:`, JSON.stringify(possibleMoves));

                    // --- Difficulty Logic --- 
                    // TODO: Implement Hard/Brutal strategies for Ultimate

                    // Easy: Choose a random valid move
                    if (difficulty === 'easy') {
                        console.log(`Ultimate AI Easy: Choosing random move from ${possibleMoves.length} options.`);
                        const chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        console.log("Ultimate AI Easy: Chosen move:", JSON.stringify(chosenMove));
                        return chosenMove;
                    }

                    // Hard / Brutal (Placeholder: Use Easy logic for now)
                    if (difficulty === 'hard' || difficulty === 'brutal') {
                        console.log(`Ultimate AI ${difficulty}: Using Easy logic (Strategy TODO).`);
                        const chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        console.log(`Ultimate AI ${difficulty}: Chosen move:`, JSON.stringify(chosenMove));
                        return chosenMove;
                    }

                    // Fallback (shouldn't be reached)
                    return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                }

                // Set up the game
                document.querySelectorAll('.cell').forEach(cell =>
                    cell.addEventListener('click', () => handleClick(parseInt(cell.dataset.index)))
                );

                // === Tournament Mode Functions ===

                function startTournamentSetup() {
                    exitTournament(); // Ensure any previous state is cleared
                    hideAllScreens();
                    tournamentSetupScreen.style.display = 'block';
                    modeToggleButtons.style.display = 'none'; // Hide mode buttons
                    // Style the active button
                    tournamentModeButton.style.background = 'linear-gradient(45deg, var(--primary), var(--secondary))';
                    aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)'; // Reset other special button
                }

                function exitTournamentSetup() {
                    tournamentSetupScreen.style.display = 'none';
                    modeToggleButtons.style.display = 'flex'; // Show mode buttons
                    // Reset special button styles
                    tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    toggleMode('classic'); // Default back to classic view
                }

                function initializeTournament() {
                    const player1Name = document.getElementById('player1Name').value || 'Player 1';
                    const player2Type = document.getElementById('player2Type').value;
                    const player2Name = player2Type === 'computer' ? 'Computer' : (document.getElementById('player2Name').value || 'Player 2');
                    isTournamentVsComputer = player2Type === 'computer';
                    if (isTournamentVsComputer) {
                        tournamentAIDifficulty = document.getElementById('tournamentAIDifficulty').value;
                    }
                    isTournamentMode = true;
                    tournamentPlayers = [
                        { name: player1Name, score: 0 },
                        { name: player2Name, score: 0 }
                    ];
                    currentTournamentRound = 0; // Will be incremented by nextTournamentRound to 1
                    hideAllScreens();
                    tournamentSetupScreen.style.display = 'none';
                    tournamentProgressDisplay.style.display = 'block';
                    modeToggleButtons.style.display = 'none'; // Keep mode buttons hidden
                    newGameButton.textContent = 'Abandon Tournament'; // Change button text
                    newGameButton.onclick = confirmAbandonTournament;
                    // Ensure the main status/roast displays are hidden initially in tournament
                    statusDisplay.style.display = 'none';
                    roastDisplay.style.display = 'none';
                    nextTournamentRound(); // Start the first round
                }

                function hideAllScreens() {
                    // Hide game boards, rules, setup, results, etc.
                    classicBoard.style.display = 'none';
                    ultimateBoardElement.style.display = 'none';
                    rulesDescriptions.forEach(el => el.classList.remove('active'));
                    tournamentSetupScreen.style.display = 'none';
                    tournamentProgressDisplay.style.display = 'none';
                    tournamentResultsScreen.style.display = 'none';
                    nextRoundButton.style.display = 'none';
                    statusDisplay.style.display = 'none'; // Hide regular status during setup/results
                    roastDisplay.style.display = 'none';
                }

                function confirmAbandonTournament() {
                    if (confirm('Are you sure you want to abandon the current tournament?')) {
                        exitTournament();
                    }
                }

                function exitTournament() {
                    isTournamentMode = false;
                    currentTournamentRound = 0;
                    tournamentPlayers = [{ name: 'Player 1', score: 0 }, { name: 'Player 2', score: 0 }];

                    hideAllScreens();
                    modeToggleButtons.style.display = 'flex'; // Show mode buttons again
                    newGameButton.textContent = 'New Game'; // Reset button text
                    newGameButton.onclick = resetGame; // Reset button action
                    statusDisplay.style.display = 'block'; // Show status
                    roastDisplay.style.display = 'block'; // Show roast area

                    // Reset special button styles
                    tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)';

                    // Ensure the correct default mode view is shown
                    const defaultMode = 'classic';
                    document.getElementById(defaultMode + 'Rules').classList.add('active');
                    classicBoard.style.display = 'grid'; // Show classic board by default
                    ultimateBoardElement.style.display = 'none';
                    toggleMode(defaultMode); // Set internal state and button styles
                }

                function nextTournamentRound() {
                    currentTournamentRound++;
                    if (currentTournamentRound <= totalTournamentRounds) {
                        startTournamentRound();
                    } else {
                        showTournamentResults();
                    }
                }

                function startTournamentRound() {
                    const roundInfo = tournamentRounds[currentTournamentRound - 1];
                    // Update progress display
                    document.getElementById('tournamentRoundTitle').textContent =
                        `Round ${currentTournamentRound}: ${roundInfo.name} (${roundInfo.points} ${roundInfo.points === 1 ? 'point' : 'points'})`;
                    document.getElementById('tournamentPlayer1Info').textContent =
                        `${tournamentPlayers[0].name} (X): ${tournamentPlayers[0].score}`;
                    document.getElementById('tournamentPlayer2Info').textContent =
                        `${tournamentPlayers[1].name} (O): ${tournamentPlayers[1].score}`;
                    tournamentProgressDisplay.style.display = 'block'; // Ensure progress is visible
                    nextRoundButton.style.display = 'none'; // Hide button until round ends
                    statusDisplay.style.display = 'block'; // Show status for the game round
                    roastDisplay.style.display = 'block'; // Show roast area
                    // Set the game mode for the current round
                    // This will also call resetGame internally to prepare the board
                    toggleMode(roundInfo.mode);
                    // Ensure the correct board is visible after toggleMode (handles early return case)
                    if (roundInfo.mode === 'ultimate') {
                        classicBoard.style.display = 'none';
                        ultimateBoardElement.style.display = 'grid';
                        initializeUltimateBoard(); // Ensure it's freshly drawn
                    } else {
                        classicBoard.style.display = 'grid';
                        ultimateBoardElement.style.display = 'none';
                    }
                    // If tournament vs computer, set AI flag and difficulty for this round
                    if (isTournamentVsComputer) {
                        isPlayingAgainstAI = true;
                        aiDifficulty = tournamentAIDifficulty;
                    } else {
                        isPlayingAgainstAI = false;
                    }
                    // If computer is O and starts, trigger AI move
                    if (isTournamentVsComputer && currentPlayer === 'O') {
                        setTimeout(triggerAIMove, 600);
                    }
                }

                function handleTournamentGameEnd(winner) {
                    // Placeholder - will implement scoring and next steps here
                    console.log(`Tournament Round ${currentTournamentRound} ended. Winner: ${winner}`);

                    const roundInfo = tournamentRounds[currentTournamentRound - 1];
                    let pointsAwarded = roundInfo.points;
                    let winnerName = "";
                    if (winner === 'X') {
                        tournamentPlayers[0].score += pointsAwarded;
                        winnerName = tournamentPlayers[0].name;
                    } else if (winner === 'O') {
                        tournamentPlayers[1].score += pointsAwarded;
                        winnerName = tournamentPlayers[1].name;
                    }

                    // Update score display immediately
                    document.getElementById('tournamentPlayer1Info').textContent =
                        `${tournamentPlayers[0].name} (X): ${tournamentPlayers[0].score}`;
                    document.getElementById('tournamentPlayer2Info').textContent =
                        `${tournamentPlayers[1].name} (O): ${tournamentPlayers[1].score}`;

                    // Show result message in the status area
                    if (winner === 'Draw') {
                        statusDisplay.textContent = `Round ${currentTournamentRound} ends in a Draw!`;
                    } else {
                        statusDisplay.textContent = `${winnerName} wins Round ${currentTournamentRound} (+${pointsAwarded} points)!`;
                    }

                    gameActive = false; // Ensure game stops
                    nextRoundButton.style.display = 'none'; // Hide button for seamless auto-progression

                    // Automatically transition to the next round after a short delay
                    setTimeout(() => {
                        if (currentTournamentRound < totalTournamentRounds) {
                            nextTournamentRound();
                        } else {
                            showTournamentResults();
                        }
                    }, 1800); // 1.8 seconds for user to see result
                }

                function showTournamentResults() {
                    // Placeholder - will implement the final results screen
                    console.log("Tournament finished. Showing results.");
                    hideAllScreens(); // Hide game elements
                    tournamentProgressDisplay.style.display = 'block'; // Keep progress visible for context

                    const p1Score = tournamentPlayers[0].score;
                    const p2Score = tournamentPlayers[1].score;
                    let winnerMessage = "";

                    if (p1Score > p2Score) {
                        winnerMessage = `ðŸ† Champion: ${tournamentPlayers[0].name} ðŸ†`;
                    } else if (p2Score > p1Score) {
                        winnerMessage = `ðŸ† Champion: ${tournamentPlayers[1].name} ðŸ†`;
                    } else {
                        winnerMessage = "ðŸ† It's a Tie! ðŸ†";
                    }

                    document.getElementById('tournamentWinner').textContent = winnerMessage;
                    document.getElementById('tournamentFinalScoreP1').textContent = `${tournamentPlayers[0].name}: ${p1Score} points`;
                    document.getElementById('tournamentFinalScoreP2').textContent = `${tournamentPlayers[1].name}: ${p2Score} points`;

                    tournamentResultsScreen.style.display = 'block';
                }

                function rematchTournament() {
                    // Simply re-initialize with the same players
                    currentTournamentRound = 0;
                    tournamentPlayers[0].score = 0;
                    tournamentPlayers[1].score = 0;

                    hideAllScreens();
                    tournamentResultsScreen.style.display = 'none';
                    tournamentProgressDisplay.style.display = 'block';
                    newGameButton.textContent = 'Abandon Tournament'; // Ensure button is correct
                    newGameButton.onclick = confirmAbandonTournament;

                    nextTournamentRound(); // Start round 1 again
                }

                // === About Screen Functions ===
                function showAboutScreen() {
                    exitTournament(); // Use exitTournament to reset to a clean state first
                    hideAllScreens();
                    aboutGameScreen.style.display = 'block';
                    modeToggleButtons.style.display = 'none'; // Hide mode buttons
                    // Style the active button
                    aboutGameButton.style.background = 'linear-gradient(45deg, var(--primary), var(--secondary))';
                    tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)'; // Reset other special button
                }

                function hideAboutScreen() {
                    aboutGameScreen.style.display = 'none';
                    // Reset special button styles (will be handled by exitTournament call below)
                    exitTournament(); // Use exitTournament to restore the default main menu view
                }
                // ==============================

                // === Computer AI Functions ===

                function showComputerSetupScreen() {
                    console.log("Executing showComputerSetupScreen..."); // Log entry
                    // exitTournament(); // DO NOT CALL THIS HERE - It resets the view!
                    hideAllScreens(); // Hide other content first
                    computerSetupScreen.style.display = 'block';
                    modeToggleButtons.style.display = 'none'; // Hide mode buttons
                    newGameButton.style.display = 'none'; // Hide new game button during setup
                    backToModesButton.style.display = 'none'; // Hide back button during setup
                    // Style the active button
                    document.getElementById('computerMode').style.background = 'linear-gradient(45deg, var(--primary), var(--secondary))';
                    // Reset other special buttons
                    tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    // Reset difficulty selection UI to default (hard)
                    setAIDifficulty('hard');
                    // Reset mode dropdown to classic
                    document.getElementById('computerGameMode').value = 'classic';
                    console.log("showComputerSetupScreen finished."); // Log exit
                }

                function cancelComputerSetup() {
                    console.log("Executing cancelComputerSetup...");
                    computerSetupScreen.style.display = 'none';
                    // Don't force view changes here, let toggleMode handle it.
                    // Reset the computerMode button style if it was active
                    document.getElementById('computerMode').style.background = 'rgba(255, 255, 255, 0.1)';
                    // We also need to ensure the main action buttons become visible again
                    // if the user cancels setup *without* choosing another mode (e.g. clicking cancel button)
                    // Check if we are NOT currently in a game (AI or tournament)
                    if (!isPlayingAgainstAI && !isTournamentMode) {
                        modeToggleButtons.style.display = 'flex'; // Show mode buttons
                        newGameButton.style.display = 'inline-block'; // Show new game button
                        backToModesButton.style.display = 'none'; // Hide back button
                        // Reset new game button
                        newGameButton.textContent = 'New Game';
                        newGameButton.onclick = resetGame;
                        // Ensure default rules/view?
                        document.getElementById('classicRules').classList.add('active');
                    }
                }

                function setAIDifficulty(difficulty) {
                    aiDifficulty = difficulty;
                    document.getElementById('aiDifficulty').value = difficulty; // Update hidden input (though we use the variable directly)
                    // Update button styles
                    document.querySelectorAll('.difficulty-btn').forEach(btn => {
                        btn.classList.remove('active');
                        if (btn.dataset.difficulty === difficulty) {
                            btn.classList.add('active');
                        }
                    });
                }

                function startComputerGame() {
                    const selectedMode = document.getElementById('computerGameMode').value;
                    // Difficulty is already set in aiDifficulty via setAIDifficulty

                    isPlayingAgainstAI = true;
                    currentMode = selectedMode;
                    console.log(`startComputerGame: Set isPlayingAgainstAI=${isPlayingAgainstAI}, currentMode=${currentMode}`); // Log state

                    hideAllScreens();
                    computerSetupScreen.style.display = 'none';
                    modeToggleButtons.style.display = 'none'; // Keep mode buttons hidden
                    newGameButton.style.display = 'inline-block'; // Show button, text/action updated in resetGame
                    statusDisplay.style.display = 'block';
                    roastDisplay.style.display = 'block';

                    // Toggle rules visibility based on selected mode
                    rulesDescriptions.forEach(el => el.classList.remove('active'));
                    const rulesId = currentMode + 'Rules';
                    const rulesElement = document.getElementById(rulesId);
                    if (rulesElement) {
                        rulesElement.classList.add('active');
                    } else { // Should not happen if modes match rules divs
                        document.getElementById('classicRules').classList.add('active');
                    }

                    // Show the correct board
                    if (currentMode === 'ultimate') {
                        classicBoard.style.display = 'none';
                        ultimateBoardElement.style.display = 'grid';
                    } else {
                        classicBoard.style.display = 'grid';
                        ultimateBoardElement.style.display = 'none';
                    }

                    console.log("startComputerGame: About to call resetGame()...");
                    resetGame(); // Initialize board, status, button text/action
                    console.log("startComputerGame: Returned from resetGame(). About to call showGameControls()...");
                    showGameControls(); // Show correct buttons for AI game
                    console.log("startComputerGame: Returned from showGameControls().");

                    // Computer ('O') might need to make the first move if currentPlayer starts as 'O'
                    // Currently, resetGame sets currentPlayer to 'X', so human always starts.
                    // If we wanted AI to start sometimes, logic would go here.
                    // triggerAIMove(); // Human ('X') starts, so AI waits for human move.
                }

                // === Computer AI Functions ===

                // Initial setup on page load
                document.addEventListener('DOMContentLoaded', () => {
                    toggleMode(currentMode); // Initialize based on the default mode ('classic')
                    setAIDifficulty(aiDifficulty); // Set initial difficulty UI just in case
                });

                function showModeSelectionScreen() {
                    console.log("Executing showModeSelectionScreen..."); // Log entry
                    hideAllScreens();
                    modeToggleButtons.style.display = 'flex';
                    newGameButton.style.display = 'inline-block'; // Show the main action button
                    backToModesButton.style.display = 'none'; // Hide back button on main screen
                    newGameButton.textContent = 'New Game'; // Reset button text
                    newGameButton.onclick = resetGame; // Reset button action
                    // Reset special button styles
                    document.getElementById('computerMode').style.background = 'rgba(255, 255, 255, 0.1)';
                    tournamentModeButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    aboutGameButton.style.background = 'rgba(255, 255, 255, 0.1)';
                    // Optionally show default rules (e.g., classic)
                    document.getElementById('classicRules').classList.add('active');
                    // Ensure no game board is visible initially
                    classicBoard.style.display = 'none';
                    ultimateBoardElement.style.display = 'none';
                    console.log("showModeSelectionScreen finished."); // Log exit
                }

                function goBackToModes() {
                    // Reset game state flags that might persist
                    isPlayingAgainstAI = false;
                    isTournamentMode = false; // Ensure tournament state is cleared
                    currentMode = 'classic'; // Reset mode conceptually
                    showModeSelectionScreen();
                    // Explicitly reset game state without starting a new visual game
                    gameBoard.fill('');
                    gameActive = false; // Game is not active on mode screen
                    currentPlayer = 'X';
                    ultimateBoard = Array(9).fill().map(() => Array(9).fill(''));
                    smallBoardWinners.fill('');
                    nextBoardIndex = -1;
                    clearAllCellTimeouts();
                }

                function showGameControls() {
                    // Shows the appropriate main action button (New Game/Change AI/Abandon) and the Back button
                    console.log("Executing showGameControls..."); // Log entry
                    newGameButton.style.display = 'inline-block';
                    backToModesButton.style.display = 'inline-block';
                    console.log(`showGameControls: newGameButton display: ${newGameButton.style.display}, backToModesButton display: ${backToModesButton.style.display}`); // Log exit
                }
                // ============================== 

                function toggleTournamentComputerOptions() {
                    const type = document.getElementById('player2Type').value;
                    const aiOpts = document.getElementById('tournamentComputerOptions');
                    const p2Name = document.getElementById('player2Name');
                    if (type === 'computer') {
                        aiOpts.style.display = 'block';
                        p2Name.value = 'Computer';
                        p2Name.disabled = true;
                    } else {
                        aiOpts.style.display = 'none';
                        p2Name.value = 'Player 2';
                        p2Name.disabled = false;
                    }
                }
            </script>
</body>

</html>